<!DOCTYPE html>

<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <!--
        hexo-theme-suka © SukkaW
        GitHub: https://github.com/SukkaW/hexo-theme-suka
    -->

    <!-- ### Resource Hint ### -->

    <!-- ## DNS Prefetch ## -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

<!-- busuanzi -->

    <link rel="dns-prefetch" href="//busuanzi.ibruce.info">


<!-- comment -->







<!-- analytics -->







    <!-- ## Preload ## -->
    
    <!-- Busuanzi -->
    
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" as="script">







    <!-- ### Meta & Title & Info ### -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <meta name="renderer" content="webkit">

    <!-- Title -->
    <title>数据结构 | Idealisti</title>

    <!-- Favicons -->
    <link rel="icon" type="image&#x2F;ico" href="/img/suka-favicon.ico">

    <!-- ### Import File ### -->
    <link rel="stylesheet" href="/lib/spectre/spectre.min.css"><style>
    body {
        background-color: #f8f9fa;
    }

    a, a:visited {
        color: #0070ff;
    }

    a:active, a:focus, a:hover {
        color: #0070ff;
        opacity: .75;
    }

    #post-content a,
    #post-content a:hover,
    #post-content a:focus,
    #post-content a:visited {
        color: #005eb9;
        opacity: 1;
    }

    

    .post-entry .card-body a {
        color: #0070ff;
    }

    .avatar {
        background: #444;
    }

    .navbar-link,
    .navbar-link:visited,
    .timeline .timeline-item .timeline-icon.icon-lg {
        color: #0070ff;
    }

    .navbar-link:hover {
        color: #0070ff;
        opacity: .8;
    }

    #search-input .btn,
    #disqus_click_btn,
    #disqus-switch-to-direct,
    #disqus-loadmore-button {
        background: #727e96;
        border-color: #727e96;
        color: #fff;
    }

    #post-toc a.post-toc-link,
    #post-toc a.post-toc-link:visited,
    .share-menu.menu .menu-item>a {
        color: #727e96;
    }

    .share-menu.menu .menu-item>a:hover,
    .share-menu.menu .menu-item>a:focus,
    .share-menu.menu .menu-item>a:visited {
        color: #50596c;
        background: #f8f9fa;
        opacity: .85;
    }
</style><link rel="stylesheet" href="/css/style.min.css">








    <!-- Prettify Theme -->
    
    <link rel="preload" href="/css/highlight/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/css/highlight/github.min.css"></noscript>





<script>
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent("onload",function(){e.poly(),t.clearInterval(a)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this);
</script>

    <!-- ### Site Verification ### -->
    


    <meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="Idealisti"><meta name="msapplication-starturl" content="https://idealisti.github.io"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Idealisti"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- ### The Open Graph & Twitter Card Protocol ### -->
    <meta property="og:title" content="数据结构 | Idealisti"><meta property="og:site_name" content="Idealisti"><meta property="og:type" content="article"><meta property="og:url" content="https://idealisti.github.io/2023/Data-Structure/"><meta property="og:locale" content="zh-CN"><meta name="description" content="我的数据结构笔记。 线性表线性表的结构体定义顺序表结构体定义1234typedef struct &amp;#123;    int data[maxSize];    int length;&amp;#125; Sqlist;  实际中用得较多的非结构体方法（更简洁）： 12int A[maxSize];int n;   定义了一个长度为n、表内元素为整数的顺序表。  单链表结点定义1234typedef st - Li Yijie - Idealisti"><meta property="article:published_time" content="2023-02-09T16:54:50.000Z"><meta property="article:modified_time" content="2023-03-12T17:00:22.867Z"><meta property="og:updated_time" content="2023-03-12T17:00:22.867Z"><meta property="article:author" content="Li Yijie"><meta name="twitter:card" content="summary">

    

    <!-- ### Canonical link ### -->
    <link rel="canonical" href="https://idealisti.github.io/2023/Data-Structure/">

    <meta name="generator" content="Hexo 6.3.0">

    <!-- ### Analytics ### -->
    







    <!-- ### Structured Data ### -->
    



<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "https://idealisti.github.io/2023/Data-Structure/",
    "@type": "BlogPosting",
    "logo": "https://idealisti.github.io/img/suka-favicon.ico",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://idealisti.github.io/2023/Data-Structure/"
    },
    "headline": "数据结构 | Idealisti",
    
    "image": {
        "@type": "ImageObject",
        "url": "https://idealisti.github.io/img/suka-favicon.ico"
    },
    
    "datePublished": "2023-02-09T16:54:50.000Z",
    "dateModified": "2023-03-12T17:00:22.867Z",
    "author": {
        "@type": "Person",
        "name": "Li Yijie",
        "image": {
            "@type": "ImageObject",
            "url": "https://idealisti.github.io/img/default_avatar.png"
        },
        "description": "Hi, nice to meet you."
    },
    "publisher": {
        "@type": "Organization",
        "name": "Idealisti",
        "logo": {
            "@type": "ImageObject",
            "url": "https://idealisti.github.io/img/suka-favicon.ico"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "https://idealisti.github.io/search?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "",
    "description": "我的数据结构笔记。 线性表线性表的结构体定义顺序表结构体定义1234typedef struct &amp;amp;#123;    int data[maxSize];    int length;&amp;amp;#125; Sqlist;  实际中用得较多的非结构体方法（更简洁）： 12int A[maxSize];int n;   定义了一个长度为n、表内元素为整数的顺序表。  单链表结点定义1234typedef st - Li Yijie - Idealisti"
}
</script>



    <!-- ### Custom Head ### -->
    
</head>

    <body>
            

            <!-- ### Main content ### -->
            <!-- ## Header ##-->
<header>
    <h1 class="header-title text-center"><a href="/">Idealisti</a></h1>

    <p class="text-center header-slogan">
        
            
                Hi, nice to meet you.
            
        
    </p>

    <nav class="navbar-section text-center">
    
        <a href="/" class="navbar-link">首页</a>
    
    
        <a href="/archives/" class="navbar-link">归档</a>
    
    
        <a href="/search" class="navbar-link">搜索</a>
    
    
    
        <div class="dropdown dropdown-right">
    <a class="navbar-link dropdown-toggle" tabindex="0">分享</a>
    <ul class="menu share-menu">

        <!-- Share Weibo -->
        
        <li class="menu-item">
            <a href="http://service.weibo.com/share/share.php?appkey=&title=Idealisti&url=https://idealisti.github.io&pic=https://idealisti.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
        </li>
        

        <!-- Share Twitter -->
        
        <li class="menu-item">
            <a href="https://twitter.com/intent/tweet?text=Idealisti&url=https://idealisti.github.io&via=Li Yijie" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
        </li>
        

        <!-- Share Facebook -->
        
        <li class="menu-item">
            <a href="https://www.facebook.com/sharer/sharer.php?u=https://idealisti.github.io" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
        </li>
        

        <!-- Share Google+ -->
        
        <li class="menu-item">
            <a href="https://plus.google.com/share?url=https://idealisti.github.io" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
        </li>
        

        <!-- Share LinkedIn -->
        
        <li class="menu-item">
            <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://idealisti.github.io&title=数据结构" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
        </li>
        

        <!-- Share QQ -->
        
        <li class="menu-item">
            <a href="http://connect.qq.com/widget/shareqq/index.html?site=Idealisti&title=数据结构&summary=&pics=https://idealisti.github.io/img/suka-favicon.ico&url=https://idealisti.github.io" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
        </li>
        

        <!-- Share Telegram -->
        
        <li class="menu-item">
            <a href="https://t.me/share/url?url=https://idealisti.github.io&text=数据结构" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
        </li>
        

        <!-- QRCode -->
        
        <li class="menu-item">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJQAAACUCAAAAABQV18IAAAB40lEQVR42u2ay27DMAwE/f8/3Z4KuAW1u2x8kOjxxUiiWGOA4mPJ62vD6wIKKKCAKqAucf38fl/76yG3NX9/q/6r9gFqFlRpdI3vK7jVXYIDNQoqMfDSOAvjd5DLfYB6BdQKwm1erQcKqCqQrkBtsAXqdVAqyHaconvOI1kCUNtDJYXDE/fHqxmgtoSyokPhJKsX6hSpH6suQG0N5R7YSQKVo3WBGqhZUCuDdQWoMmJXTLQ8OlBHQUWLGwmcEkPcSwE1AyoV8906t1YdIqDmQbkgqoqM1MCVMwVqFtSnTZ+kSRk3LYEaAZUIqonInx4KmfwBNRrKCV4qOVSOsy1wAHUklDPS5BAkL2adLVAjoJRjdOKZCrCpwAHUXKjuhk7YSIxeZp5AHQulgmUinCkD7gyAATUHSg1HpI40PQBq6AKoOVBJs8glZ66x5BpKQM2CSg0yHdRKhr+iwgGo46Gc0OqK1kTwcEEdqBlQHYEjXd8RRuKADNQxUFYcNcle0hCPHS9QI6CSgWY3IOGSuaQBCdQsqDQ4u6CbFA/qM1CzoLoDy07I+FezHKhXQKWbpqK/FFSAeg1UavxJU7IVkIE6GioNyN3B+GTwBqh5UB2BIjkUbrg5SvKAOhZqpwsooIAC6nZ9A88Kv/84NEh5AAAAAElFTkSuQmCC" alr="QRCode">
        </li>
        

    </ul>
</div>
    
    
</nav>
</header>

            
    <!-- ## Post ## -->
    <div class="post-container">
    <div id="post-card" class="card">
        
        <div class="card-item-container">
            <div class="card-inner-cell">
                <!-- # Post Header Info # -->
                <div class="card-header">
                    
    <h1 class="card-title h3 mb-2">数据结构</h1>




<div class="post-header-info">
    <p class="post-header-info-left text-gray">
        <img class="author-thumb lazyload" data-src="/img/default_avatar.png" src="/img/suka-lazyload.gif" alt="Li Yijie's Avatar">
        <span>2023-02-10</span>
        
        
            <!-- Busuanzi Post Views -->
<span id="busuanzi_container_page_pv" hidden>
    <span class="suka-devide-dot"></span>
    <span></span>
    <span id="busuanzi_value_page_pv"></span>
    <span>Views</span>
</span>
        
        
    </p>
    <div class="post-header-info-right">
        
            <div class="dropdown dropdown-right">
<a class="dropdown-toggle" tabindex="0">分享本文</a>
<ul class="menu share-menu">
    <!-- Share Weibo -->
    
    <li class="menu-item">
        <a href="http://service.weibo.com/share/share.php?appkey=&title=数据结构&url=https://idealisti.github.io/2023/Data-Structure/&pic=https://idealisti.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
    </li>
    

    <!-- Share Twitter -->
    
    <li class="menu-item">
        <a href="https://twitter.com/intent/tweet?text=数据结构&url=https://idealisti.github.io/2023/Data-Structure/&via=Li Yijie" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
    </li>
    

    <!-- Share Facebook -->
    
    <li class="menu-item">
        <a href="https://www.facebook.com/sharer/sharer.php?u=https://idealisti.github.io/2023/Data-Structure/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
    </li>
    

    <!-- Share Google+ -->
    
    <li class="menu-item">
        <a href="https://plus.google.com/share?url=https://idealisti.github.io/2023/Data-Structure/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
    </li>
    

    <!-- Share LinkedIn -->
    
    <li class="menu-item">
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://idealisti.github.io/2023/Data-Structure/&title=Idealisti" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
    </li>
    

    <!-- Share QQ -->
    
    <li class="menu-item">
        <a href="http://connect.qq.com/widget/shareqq/index.html?site=Idealisti&title=Idealisti&summary=&pics=https://idealisti.github.io/img/suka-favicon.ico&url=https://idealisti.github.io/2023/Data-Structure/" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
    </li>
    

    <!-- Share Telegram -->
    
    <li class="menu-item">
        <a href="https://t.me/share/url?url=https://idealisti.github.io/2023/Data-Structure/&text=Idealisti" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
    </li>
    

    <!-- QRCode -->
    
    <li class="menu-item">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJQAAACUCAAAAABQV18IAAAB40lEQVR42u2ay27DMAwE/f8/3Z4KuAW1u2x8kOjxxUiiWGOA4mPJ62vD6wIKKKCAKqAucf38fl/76yG3NX9/q/6r9gFqFlRpdI3vK7jVXYIDNQoqMfDSOAvjd5DLfYB6BdQKwm1erQcKqCqQrkBtsAXqdVAqyHaconvOI1kCUNtDJYXDE/fHqxmgtoSyokPhJKsX6hSpH6suQG0N5R7YSQKVo3WBGqhZUCuDdQWoMmJXTLQ8OlBHQUWLGwmcEkPcSwE1AyoV8906t1YdIqDmQbkgqoqM1MCVMwVqFtSnTZ+kSRk3LYEaAZUIqonInx4KmfwBNRrKCV4qOVSOsy1wAHUklDPS5BAkL2adLVAjoJRjdOKZCrCpwAHUXKjuhk7YSIxeZp5AHQulgmUinCkD7gyAATUHSg1HpI40PQBq6AKoOVBJs8glZ66x5BpKQM2CSg0yHdRKhr+iwgGo46Gc0OqK1kTwcEEdqBlQHYEjXd8RRuKADNQxUFYcNcle0hCPHS9QI6CSgWY3IOGSuaQBCdQsqDQ4u6CbFA/qM1CzoLoDy07I+FezHKhXQKWbpqK/FFSAeg1UavxJU7IVkIE6GioNyN3B+GTwBqh5UB2BIjkUbrg5SvKAOhZqpwsooIAC6nZ9A88Kv/84NEh5AAAAAElFTkSuQmCC" alt="QRCode">
    </li>
    

</ul>
</div>
        
    </div>
</div>
                </div>
                <div class="card-body">
                    
                        
                        
                            <div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="post-toc-number">1.</span> <span class="post-toc-text">线性表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">线性表的结构体定义</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">顺序表结构体定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">单链表结点定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">双链表结点定义</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">顺序表的操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8C%89%E5%85%83%E7%B4%A0%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">按元素值查找</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">插入数据元素</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">删除数据元素</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">单链表的操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">建立单链表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">插入与删除结点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BD%92%E5%B9%B6"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">归并</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">查找</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">双链表的操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">建立双链表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9F%A5%E6%89%BE%E7%BB%93%E7%82%B9"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">查找结点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">插入结点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">删除结点</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">循环链表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%80%86%E7%BD%AE%E9%97%AE%E9%A2%98"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">逆置问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="post-toc-number">2.</span> <span class="post-toc-text">栈和队列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">顺序栈的操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">结构体定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">初始化栈</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">判断栈空</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%9B%E6%A0%88"><span class="post-toc-number">2.1.4.</span> <span class="post-toc-text">进栈</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BA%E6%A0%88"><span class="post-toc-number">2.1.5.</span> <span class="post-toc-text">出栈</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B8%B8%E7%94%A8%E5%86%99%E6%B3%95"><span class="post-toc-number">2.1.6.</span> <span class="post-toc-text">常用写法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">链栈的操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">结点定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">初始化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA-1"><span class="post-toc-number">2.2.3.</span> <span class="post-toc-text">判断栈空</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%9B%E6%A0%88-1"><span class="post-toc-number">2.2.4.</span> <span class="post-toc-text">进栈</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BA%E6%A0%88-1"><span class="post-toc-number">2.2.5.</span> <span class="post-toc-text">出栈</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">栈的应用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">顺序栈的应用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">链栈的应用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">顺序队</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89-1"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">结构体定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97"><span class="post-toc-number">2.4.2.</span> <span class="post-toc-text">初始化队列</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA"><span class="post-toc-number">2.4.3.</span> <span class="post-toc-text">判断队空</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%9B%E9%98%9F"><span class="post-toc-number">2.4.4.</span> <span class="post-toc-text">进队</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BA%E9%98%9F"><span class="post-toc-number">2.4.5.</span> <span class="post-toc-text">出队</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%93%BE%E9%98%9F"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">链队</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89-2"><span class="post-toc-number">2.5.1.</span> <span class="post-toc-text">结构体定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97-1"><span class="post-toc-number">2.5.2.</span> <span class="post-toc-text">初始化队列</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA-1"><span class="post-toc-number">2.5.3.</span> <span class="post-toc-text">判断队空</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%A5%E9%98%9F"><span class="post-toc-number">2.5.4.</span> <span class="post-toc-text">入队</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BA%E9%98%9F-1"><span class="post-toc-number">2.5.5.</span> <span class="post-toc-text">出队</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%B2"><span class="post-toc-number">3.</span> <span class="post-toc-text">串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89-3"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">结构体定义</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9A%E9%95%BF%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">定长顺序存储</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%98%E9%95%BF%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">变长分配存储</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">基本操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">赋值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%96%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">取串长度</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">串比较</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%B2%E8%BF%9E%E6%8E%A5"><span class="post-toc-number">3.2.4.</span> <span class="post-toc-text">串连接</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B1%82%E5%AD%90%E4%B8%B2"><span class="post-toc-number">3.2.5.</span> <span class="post-toc-text">求子串</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%B2%E6%B8%85%E7%A9%BA"><span class="post-toc-number">3.2.6.</span> <span class="post-toc-text">串清空</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">模式匹配</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">简单模式匹配算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">KMP算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#KMP%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="post-toc-number">3.3.3.</span> <span class="post-toc-text">KMP算法的改进</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="post-toc-number">4.</span> <span class="post-toc-text">树与二叉树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">二叉树的存储结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">顺序存储</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="post-toc-number">4.1.2.</span> <span class="post-toc-text">链式存储</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">二叉树的遍历算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">先序遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="post-toc-number">4.2.2.</span> <span class="post-toc-text">中序遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="post-toc-number">4.2.3.</span> <span class="post-toc-text">后序遍历</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="post-toc-number">4.2.4.</span> <span class="post-toc-text">层次遍历</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">线索二叉树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89-4"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">结构体定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">中序线索二叉树</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">树和森林与二叉树的转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="post-toc-number">4.4.1.</span> <span class="post-toc-text">树与二叉树的相互转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="post-toc-number">4.4.2.</span> <span class="post-toc-text">森林与二叉树的相互转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="post-toc-number">4.4.3.</span> <span class="post-toc-text">树和森林的遍历</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">赫夫曼树和赫夫曼编码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9E%84%E9%80%A0%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="post-toc-number">4.5.1.</span> <span class="post-toc-text">构造赫夫曼树</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="post-toc-number">4.5.2.</span> <span class="post-toc-text">赫夫曼编码</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%9B%BE"><span class="post-toc-number">5.</span> <span class="post-toc-text">图</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">邻接矩阵</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">邻接表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">图的遍历算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86DFS"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">深度优先搜索遍历DFS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">广度优先搜索遍历</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%80%E5%B0%8F%EF%BC%88%E4%BB%A3%E4%BB%B7%EF%BC%89%E7%94%9F%E6%88%90%E6%A0%91"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">最小（代价）生成树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95"><span class="post-toc-number">5.4.1.</span> <span class="post-toc-text">普里姆算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="post-toc-number">5.4.2.</span> <span class="post-toc-text">克鲁斯卡尔算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">最短路径</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="post-toc-number">5.5.1.</span> <span class="post-toc-text">迪杰斯特拉算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95"><span class="post-toc-number">5.5.2.</span> <span class="post-toc-text">弗洛伊德算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">拓扑排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-1"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">最短路径</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.</span> <span class="post-toc-text">排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8F%92%E5%85%A5%E7%B1%BB%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">插入类排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">直接插入排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.1.2.</span> <span class="post-toc-text">折半插入排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.1.3.</span> <span class="post-toc-text">希尔排序</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">交换类排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B5%B7%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.2.1.</span> <span class="post-toc-text">起泡排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.2.2.</span> <span class="post-toc-text">快速排序</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">选择类排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.3.1.</span> <span class="post-toc-text">简单选择排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.3.2.</span> <span class="post-toc-text">堆排序</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">二路归并排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="post-toc-number">6.5.</span> <span class="post-toc-text">基数排序</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%9F%A5%E6%89%BE-1"><span class="post-toc-number">7.</span> <span class="post-toc-text">查找</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">顺序查找法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">折半查找法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">二叉排序树（二叉查找树）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="post-toc-number">7.3.1.</span> <span class="post-toc-text">存储结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95"><span class="post-toc-number">7.3.2.</span> <span class="post-toc-text">基本算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%E6%A0%91%EF%BC%89"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">平衡二叉树（AVL树）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B-%E6%A0%91%EF%BC%88B%E6%A0%91%EF%BC%89"><span class="post-toc-number">7.5.</span> <span class="post-toc-text">B-树（B树）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88Hash%E8%A1%A8%EF%BC%89"><span class="post-toc-number">7.6.</span> <span class="post-toc-text">散列表（Hash表）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="post-toc-number">7.6.1.</span> <span class="post-toc-text">构造方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="post-toc-number">7.6.2.</span> <span class="post-toc-text">冲突处理方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="post-toc-number">7.6.3.</span> <span class="post-toc-text">性能分析</span></a></li></ol></li></ol></li></ol></div>
                        
                    
                    <article id="post-content">
                        <p>我的数据结构笔记。</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表的结构体定义"><a href="#线性表的结构体定义" class="headerlink" title="线性表的结构体定义"></a>线性表的结构体定义</h3><h4 id="顺序表结构体定义"><a href="#顺序表结构体定义" class="headerlink" title="顺序表结构体定义"></a>顺序表结构体定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[maxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; Sqlist;</span><br></pre></td></tr></table></figure>

<p>实际中用得较多的非结构体方法（更简洁）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[maxSize];</span><br><span class="line"><span class="type">int</span> n;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义了一个长度为n、表内元素为整数的顺序表。</p>
</blockquote>
<h4 id="单链表结点定义"><a href="#单链表结点定义" class="headerlink" title="单链表结点定义"></a>单链表结点定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode;</span><br></pre></td></tr></table></figure>

<h4 id="双链表结点定义"><a href="#双链表结点定义" class="headerlink" title="双链表结点定义"></a>双链表结点定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DLNode;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造链表结点时定义一个指针来存储这片空间的地址（即指针指向节点），并常用这个指针的名称来作为结点的名称，例如：</p>
<p><code>LNode *A = (LNode *)malloc(sizeof(LNode));</code></p>
</blockquote>
<h3 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h3><h4 id="按元素值查找"><a href="#按元素值查找" class="headerlink" title="按元素值查找"></a>按元素值查找</h4><p>在顺序表<code>L</code>中查找第一个值等于<code>e</code>的元素，并返回下标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findElem</span><span class="params">(Sqlist L, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e==L.data[i])</span><br><span class="line">            <span class="keyword">return</span> i;    <span class="comment">//若找到，则返回下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">//没找到，返回-1作为失败标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入数据元素"><a href="#插入数据元素" class="headerlink" title="插入数据元素"></a>插入数据元素</h4><p>在顺序表<code>L</code>的<code>p (0≤p≤length)</code>位置插入新的元素<code>e</code>。<code>p</code>输入不正确返回<code>0</code>，插入操作成功返回<code>1</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertElem</span><span class="params">(Sqlist &amp;L, <span class="type">int</span> p, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span> || p&gt;L.length || L.length==maxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i==L.length<span class="number">-1</span>; i&gt;=p; i--)</span><br><span class="line">        L.data[i+<span class="number">1</span>] = L.data[i];</span><br><span class="line">    L.data[p] = e;</span><br><span class="line">    (L.length)++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据元素"><a href="#删除数据元素" class="headerlink" title="删除数据元素"></a>删除数据元素</h4><p>删除顺序表下标为<code>p (0≤p≤length-1)</code>的元素，成功返回<code>1</code>，否则返回<code>0</code>，并将被删除元素的值赋给<code>e</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteElem</span><span class="params">(Sqlist &amp;L, <span class="type">int</span> p, <span class="type">int</span> &amp;e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span> || p&gt;L.length<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    e = L.data[p];</span><br><span class="line">    <span class="keyword">for</span>(i=p; i&lt;L.length<span class="number">-1</span>; i++)</span><br><span class="line">        L.data[i] = L.data[i+<span class="number">1</span>];</span><br><span class="line">    (L.length)--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h3><h4 id="建立单链表"><a href="#建立单链表" class="headerlink" title="建立单链表"></a>建立单链表</h4><p>假设有n个元素已经存储在数组<code>a</code>中，用<strong>尾插法</strong>建立链表<code>C</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createlistR</span><span class="params">(LNode *&amp;C, <span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    LNode *s, *r;    <span class="comment">//s指向新申请的结点，r始终指向C的终端结点</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    C = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));    <span class="comment">//申请C的头结点空间</span></span><br><span class="line">    C-&gt;next = <span class="literal">NULL</span>;    <span class="comment">//每申请一个新结点时，将指针域next设置为NULL以避免产生错误</span></span><br><span class="line">    r = C;    <span class="comment">//此时C的头结点就是终端结点</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = r-&gt;next;    <span class="comment">//等价于 r=s</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<strong>头插法</strong>建立链表<code>C</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createlistF</span><span class="params">(LNode *&amp;C, <span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    C = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        s-&gt;next = C-&gt;next;    <span class="comment">//s所指新结点的指针域next指向C的开始结点</span></span><br><span class="line">        C-&gt;next = s;    <span class="comment">//头结点的指针域next指向s结点，使s成为新的开始结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入与删除结点"><a href="#插入与删除结点" class="headerlink" title="插入与删除结点"></a>插入与删除结点</h4><p>假设<code>p</code>指向一个结点，要将<code>s</code>所指结点插入<code>p</code>所指结点之后。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>

<p>删除第i个结点，需找到第i-1个结点<code>p</code>（注意要释放内存空间）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>

<h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><p><code>A</code>和<code>B</code>是两个单链表（带头结点），元素递增有序，将<code>A</code>和<code>B</code>归并成一个按元素递增的链表<code>C</code>，<code>C</code>由<code>A</code>和<code>B</code>的结点组成。</p>
<blockquote>
<p>从<code>A</code>、<code>B</code>中挑出最小的元素插入<code>C</code>的尾部，<code>C</code>一定是递增有序的。如果<code>A</code>、<code>B</code>其中一个已经全部插入<code>C</code>中，再将另一个链接到<code>C</code>的尾部即可。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(LNode *A, LNode *B, LNode *&amp;C)</span> &#123;</span><br><span class="line">    LNode *p = A-&gt;next;    <span class="comment">//p跟踪A的最小值结点</span></span><br><span class="line">    LNode *q = B-&gt;next;    <span class="comment">//q跟踪B的最小值结点</span></span><br><span class="line">    LNode *r;    <span class="comment">//r始终指向C的终端结点</span></span><br><span class="line">    C = A;    <span class="comment">//用A的头结点来做C的头结点</span></span><br><span class="line">    C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);    <span class="comment">//B的头结点已经无用，释放</span></span><br><span class="line">    r = C;    <span class="comment">//此时C的头结点就是终端结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; q!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/*以下 if else 中，r始终指向当前链表的终端结点，用尾插法*/</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &lt;= q-&gt;data) &#123;</span><br><span class="line">            r-&gt;next = p; p = p-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            r-&gt;next = q; q = q-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*以下两个if语句将还有剩余结点的链表链接到C的尾部*/</span></span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">    <span class="keyword">if</span>(q!=<span class="literal">NULL</span>)</span><br><span class="line">        r-&gt;next = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>A</code>和<code>B</code>归并成一个按元素递减的链表<code>C</code>。</p>
<blockquote>
<p>改成头插法即可解决。不需要<code>r</code>追踪<code>C</code>的终端结点，而是用<code>s</code>来接收新的结点，插入<code>C</code>的前端。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(LNode *A, LNode *B, LNode *&amp;C)</span> &#123;</span><br><span class="line">    LNode *p = A-&gt;next;</span><br><span class="line">    LNode *q = B-&gt;next;</span><br><span class="line">    LNode *s;</span><br><span class="line">    C = A;</span><br><span class="line">    C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; q!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/*以下 if else 语句体现了头插法*/</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &lt;= q-&gt;data) &#123;</span><br><span class="line">            s = p; p = p-&gt;next;</span><br><span class="line">            s-&gt;next = C-&gt;next;</span><br><span class="line">            C-&gt;next = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s = q; q = q-&gt;next;</span><br><span class="line">            s-&gt;next = C-&gt;next;</span><br><span class="line">            C-&gt;next = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*必须将剩余元素逐个插入C的头部*/</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        s = p; p = p-&gt;next;</span><br><span class="line">        s-&gt;next = C-&gt;next;</span><br><span class="line">        C-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        s = q; q = q-&gt;next;</span><br><span class="line">        s-&gt;next = C-&gt;next;</span><br><span class="line">        C-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>查找链表<code>C</code>中是否存在一个值为<code>x</code>的结点，若存在则删除该结点并返回<code>1</code>，否则返回<code>0</code>。</p>
<blockquote>
<p>定义结点指针变量<code>p</code>，沿着链表一直走到表尾，每遇到一个新结点就检测其值是否为<code>x</code>，是则证明找到，不是则继续检测下一个结点。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findAndDelete</span><span class="params">(LNode *C, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    LNode *p, *q;</span><br><span class="line">    p = C;</span><br><span class="line">    <span class="comment">/*查找部分开始*/</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next-&gt;data == x)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*查找部分结束*/</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*删除部分开始*/</span></span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">        <span class="comment">/*删除部分结束*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表的操作"><a href="#双链表的操作" class="headerlink" title="双链表的操作"></a>双链表的操作</h3><h4 id="建立双链表"><a href="#建立双链表" class="headerlink" title="建立双链表"></a>建立双链表</h4><p>使用<strong>尾插法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createDlistR</span><span class="params">(DLNode *&amp;L, <span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    DLNode *s, *r;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    L = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    r = L;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        s = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        s-&gt;prior = r;    <span class="comment">//这一句是与建立单链表不同的地方</span></span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查找结点"><a href="#查找结点" class="headerlink" title="查找结点"></a>查找结点</h4><p>在双链表中查找第一个值为<code>x</code>的结点，若找到则返回结点指针，否则返回<code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DLNode* <span class="title function_">findNode</span><span class="params">(DLNode *C, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    DLNode *p = C-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==x)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果找到，则<code>p</code>中内容是结点地址（循环因<code>break</code>结束）；如果没找到，则<code>p</code>中的内容为<code>NULL</code>（循环因<code>p</code>等于<code>NULL</code>而结束）。</p>
</blockquote>
<h4 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h4><p>在双链表中<code>p</code>所指的结点之后插入一个结点<code>s</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">s-&gt;prior = p;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line">s-&gt;next-&gt;prior = s;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先将要插入结点的两边链接好，就可以避免断链后找不到结点的情况。</p>
</blockquote>
<h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><p>删除双链表中<code>p</code>结点的<strong>后继结点</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表的各种操作均与非循环链表类似。需要注意的是，如果<code>p</code>指针沿着循环链表行走，则判断<code>p</code>走到表尾结点的条件是<code>p-&gt;next==head</code>。</p>
<h3 id="逆置问题"><a href="#逆置问题" class="headerlink" title="逆置问题"></a>逆置问题</h3><p>将线性表的元素逆置，可设置两个整形变量<code>i</code>和<code>j</code>，<code>i</code>指向第一个元素，<code>j</code>指向最后一个元素，边交换<code>i</code>和<code>j</code>所指元素，边让<code>i</code>和<code>j</code>相向而行，直到相遇。假设元素存在于数组<code>a[]</code>中，<code>left</code>和<code>right</code>是数组两端元素的下标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=left, j=right; i&lt;j; i++, j--) &#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例题</strong></p>
<ol>
<li><p>将一个长度为n的数组的前端 k(k&lt;n) 个元素逆序移动到数组后端，要求原数组中数据不丢失，其余元素的位置无关紧要。</p>
</li>
<li><p>将一个长度为n的数组的前端 k(k&lt;n) 个元素保持原序移动到数组后端，要求原数组中数据不丢失，其余元素的位置无关紧要。</p>
</li>
<li><p>将数组中的元素 (X0, X1, …, Xn-1)，经过移动后变为 (Xp, Xp+1, …, Xn-1, X0, X1, …, Xp-1)，即循环左移 p(0&lt;p&lt;n) 个位置。</p>
</li>
</ol>
<p><strong>分析</strong></p>
<ol>
<li><p>逆置整个数组，即可满足前端k个元素逆序后放到数组后端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=left, j=right; i&lt;left+k &amp;&amp; i&lt;j; i++, j--) &#123;</span><br><span class="line">      temp = a[i];</span><br><span class="line">      a[i] = a[j];</span><br><span class="line">      a[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将前端k个元素逆置，然后将整个数组逆置，即可满足前端k个元素原序放到数组后端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveToEnd</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">  <span class="comment">//调用(1)中实现的reverse()函数</span></span><br><span class="line">  reverse(a, <span class="number">0</span>, k<span class="number">-1</span>, k);</span><br><span class="line">  reverse(a, <span class="number">0</span>, n<span class="number">-1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将0到p-1位置的元素逆置，再将p到n-1位置的元素逆置，然后将整个数组逆置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveP</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">  reverse(a, <span class="number">0</span>, p<span class="number">-1</span>, p);</span><br><span class="line">  reverse(a, p, n<span class="number">-1</span>, n-p);</span><br><span class="line">  reverse(a, <span class="number">0</span>, n<span class="number">-1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="顺序栈的操作"><a href="#顺序栈的操作" class="headerlink" title="顺序栈的操作"></a>顺序栈的操作</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[maxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure>

<h4 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h4><p>只需将栈顶指针置为<code>-1</code>即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(SqStack &amp;st)</span> &#123;</span><br><span class="line">    st.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h4><p>栈<code>st</code>为空时返回<code>1</code>，否则返回<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inEmpty</span><span class="params">(SqStack st)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(st.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">push</span><span class="params">(SqStack &amp;st, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(st.top==maxSize<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    st.top++;</span><br><span class="line">    st.data[st.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(SqStack &amp;st, <span class="type">int</span> &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(st.top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = st.data[st.top];</span><br><span class="line">    st.top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常用写法"><a href="#常用写法" class="headerlink" title="常用写法"></a>常用写法</h4><p>栈常常作为一个工具来解决其他问题，因此一般情况下，栈的定义和操作可以写得很简单，不必调用以上函数。</p>
<ol>
<li><p>定义一个栈并初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">stack</span>[maxSize]; <span class="type">int</span> top=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素<code>x</code>进栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>[++top] = x;</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素<code>x</code>出栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">stack</span>[top--];</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2与3需注意的是，当前栈是否为满，满时不进；是否为空，空时不出。根据实际需要决定写还是不写，不必像标准操作那样每次都判断。</p>
<h3 id="链栈的操作"><a href="#链栈的操作" class="headerlink" title="链栈的操作"></a>链栈的操作</h3><h4 id="结点定义"><a href="#结点定义" class="headerlink" title="结点定义"></a>结点定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode;</span><br></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(LNode *&amp;lst)</span> &#123;</span><br><span class="line">    lst = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    lst-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断栈空-1"><a href="#判断栈空-1" class="headerlink" title="判断栈空"></a>判断栈空</h4><p>当栈空时返回<code>1</code>，否则返回<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(LNode *lst)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(lst-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h4><p>栈不空时可以执行，返回<code>1</code>，否则返回<code>0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(LNode *lst, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*以下三句就是链表的头插法*/</span></span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    p-&gt;next = lst-&gt;next;</span><br><span class="line">    lst-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(LNode *lst, <span class="type">int</span> &amp;x)</span> &#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">if</span>(lst-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*以下就是单链表的删除操作*/</span></span><br><span class="line">    p = lst-&gt;next;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    lst-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>和顺序栈一样，不必严格写出操作函数，只需摘取必要的语句结合在代码中即可。</p>
</blockquote>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><h4 id="顺序栈的应用"><a href="#顺序栈的应用" class="headerlink" title="顺序栈的应用"></a>顺序栈的应用</h4><p><strong>【例3-1】</strong> C语言算数表达式中的括号只有小括号。编写算法，判断一个表达式中的括号是否正确配对，表达式已经存入字符数组<code>exp[]</code>中，表达式的字符个数为<code>n</code>。</p>
<blockquote>
<p>一个问题中如果出现诸如这种情况，即在解决问题的过程中出现了一个子问题，但凭现有条件不能解决它，需要记下，等待以后出现可以解决它的条件后再返回来解决。这种问题需要用栈来解决，这是栈的FILO特性所延申出来的一种特性。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">match</span><span class="params">(<span class="type">char</span> <span class="built_in">exp</span>[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[maxSize]; <span class="type">int</span> top=<span class="number">-1</span>;    <span class="comment">//两句话完成栈的定义和初始化</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">exp</span>[i]==<span class="string">&#x27;(&#x27;</span>)    <span class="comment">//如果遇到“/”，则入栈等待以后处理</span></span><br><span class="line">            <span class="built_in">stack</span>[++top] = <span class="string">&#x27;(&#x27;</span>;    <span class="comment">//一句话完成入栈操作</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">exp</span>[i]==<span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(top==<span class="number">-1</span>)    <span class="comment">//如果当前遇到“)”并且栈已空，则不匹配，返回0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                top--;    <span class="comment">//如果栈不空则出栈，一对括号处理完毕</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【例3-2】</strong> 编写一个函数，求后缀式的数值，其中后缀式存于一个字符数组<code>exp</code>中，其中最后一个字符是<code>\0</code>作为结束符，并且假设后缀式中的数字都只有一位。本题的除法运算皆为整数运算，如2&#x2F;3结果为0，3&#x2F;2结果为1。</p>
<blockquote>
<p><code>(a+b+c×d)/e</code>是一个中缀式，转化为前缀式为<code>/++ab×cde</code>，转化为后缀式为<code>abcd×++e/</code>。</p>
</blockquote>
<p>后缀式的求值可以用栈解决。对于一个后缀式，当从左往右扫描到一个数值时，具体怎么运算还不知道，需要扫描到后面的运算符才知道，因此必须先存起来。</p>
<p>执行过程：当遇到数值时入栈，当遇到运算符时连续两次出栈，将两个出栈元素结合运算符进行运算，将结果作为新遇到的数值入栈。如此往复，直到扫描到终止符<code>\0</code>。此时栈底元素即为表达式的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">op</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> Op, <span class="type">int</span> b)</span> &#123;    <span class="comment">//运算函数，用来完成算式 a Op b 的运算</span></span><br><span class="line">    <span class="keyword">if</span>(Op==<span class="string">&#x27;+&#x27;</span>)    <span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">if</span>(Op==<span class="string">&#x27;-&#x27;</span>)    <span class="keyword">return</span> a-b;</span><br><span class="line">    <span class="keyword">if</span>(Op==<span class="string">&#x27;*&#x27;</span>)    <span class="keyword">return</span> a*b;</span><br><span class="line">    <span class="keyword">if</span>(Op==<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ERROR&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">com</span><span class="params">(<span class="type">char</span> <span class="built_in">exp</span>[])</span> &#123;    <span class="comment">//后缀式计算函数</span></span><br><span class="line">    <span class="type">int</span> i, a, b, c;    <span class="comment">//a、b为操作数，c保存结果</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">stack</span>[maxSize]; <span class="type">int</span> top=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> Op;    <span class="comment">//Op取运算符</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; <span class="built_in">exp</span>[i]!=<span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">exp</span>[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">exp</span>[i]&gt;=<span class="string">&#x27;9&#x27;</span>)    <span class="comment">//遇到操作数则入栈</span></span><br><span class="line">            <span class="built_in">stack</span>[++top] = <span class="built_in">exp</span>[i] - <span class="string">&#x27;0&#x27;</span>;    <span class="comment">//字符型和整型的转换</span></span><br><span class="line">        <span class="keyword">else</span> &#123;    <span class="comment">//遇到运算符，说明带处理数字的处理条件已经具备，开始运算</span></span><br><span class="line">            Op = <span class="built_in">exp</span>[i];</span><br><span class="line">            b = <span class="built_in">stack</span>[top--];</span><br><span class="line">            a = <span class="built_in">stack</span>[top--];</span><br><span class="line">            c = op(a, Op, b);</span><br><span class="line">            <span class="built_in">stack</span>[++top] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设有一个字符<code>&#39;5&#39;</code>，定义一个整形变量<code>a=&#39;5&#39;</code>，此时a里保存了5的ASCII码，而不是数字5。要将5这个整数保存于a中，需执行<code>a=&#39;5&#39;-&#39;0&#39;</code>。同理，把一个整形数字a装华为对应的字符型数字存储在字符变量b中，需执行<code>b=a+&#39;0&#39;</code>。但是这种转化只适用于0~9这10个数字。</p>
</blockquote>
<h4 id="链栈的应用"><a href="#链栈的应用" class="headerlink" title="链栈的应用"></a>链栈的应用</h4><p><strong>【例3-3】</strong> 用不带头结点的单链表存储链栈，设计初始化栈、判断栈是否为空、进栈和出栈等算法。</p>
<p>不带头结点的单链表<code>lst</code>为空的条件是<code>lst==NULL</code>，进栈和出栈操作都是在表头进行的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ininStackl</span><span class="params">(LNode *&amp;lst)</span> &#123;    <span class="comment">//初始化栈</span></span><br><span class="line">    lst = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmptyl</span><span class="params">(LNode *lst)</span> &#123;    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(lst==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pushl</span><span class="params">(LNode *&amp;lst, <span class="type">int</span> x)</span> &#123;    <span class="comment">//进栈</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    <span class="comment">/*下面是插入操作*/</span></span><br><span class="line">    p-&gt;next = lst;</span><br><span class="line">    lst = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">popl</span><span class="params">(LNode *&amp;lst, <span class="type">int</span> &amp;x)</span> &#123;    <span class="comment">//出栈</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">if</span>(lst==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    p = lst;</span><br><span class="line">    <span class="comment">/*删除结点*/</span></span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    lst = p-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序队"><a href="#顺序队" class="headerlink" title="顺序队"></a>顺序队</h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[maxSize];</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>

<p>以下算法在元素入队时，先移动指针，后存入元素；元素出队时，也是先移动指针，后取出元素。选择题根据实际情况来确定先移动指针还是先存取元素。</p>
<h4 id="初始化队列"><a href="#初始化队列" class="headerlink" title="初始化队列"></a>初始化队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(SqQueue &amp;qu)</span> &#123;</span><br><span class="line">    qu.front = qu.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断队空"><a href="#判断队空" class="headerlink" title="判断队空"></a>判断队空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isQueueEmpty</span><span class="params">(SqQueue &amp;qu)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(qu.front==qu.rear)    <span class="comment">//不论队首、队尾指针指向哪个位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;            <span class="comment">//只要两者重合，即为队空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进队"><a href="#进队" class="headerlink" title="进队"></a>进队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">enQueue</span><span class="params">(SqQueue &amp;qu, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((qu.rear+<span class="number">1</span>)%maxSize==qu.front)    <span class="comment">//判断队满条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    qu.rear = (qu.rear)+<span class="number">1</span> % maxSize;</span><br><span class="line">    qu.data[qu.rear] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(SqQueue &amp;qu, <span class="type">int</span> &amp;x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(qu.front==qu.rear)    <span class="comment">//判断队空条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    qu.front = (qu.front+<span class="number">1</span>) % maxSize;</span><br><span class="line">    x = qu.data[qu.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上函数在书写程序时并不实用，提出其中有用的操作即可。</p>
</blockquote>
<h3 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a>结构体定义</h4><ol>
<li><p>队节点类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; QNode;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链队类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">QNode *front;</span><br><span class="line">QNode *rear;</span><br><span class="line">&#125; LiQueue;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="初始化队列-1"><a href="#初始化队列-1" class="headerlink" title="初始化队列"></a>初始化队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(LiQueue *&amp;lqu)</span> &#123;</span><br><span class="line">    lqu = (LiQueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LiQueue));</span><br><span class="line">    lqu-&gt;front = lqu-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断队空-1"><a href="#判断队空-1" class="headerlink" title="判断队空"></a>判断队空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isQueueEmpty</span><span class="params">(LiQueue *lqu)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(lqu-&gt;rear==<span class="literal">NULL</span> || lqu-&gt;front==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(LiQueue *lqu, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    QNode *p;</span><br><span class="line">    p = (QNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(lqu-&gt;rear==<span class="literal">NULL</span>)    <span class="comment">//若队列为空，则新结点是队首结点，也是队尾结点</span></span><br><span class="line">        lqu-&gt;front = lqu-&gt;rear = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        lqu-&gt;rear-&gt;next = p;    <span class="comment">//将新结点链接到队尾，rear指向它</span></span><br><span class="line">        lqu-&gt;rear = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(LiQueue *lqu, <span class="type">int</span> &amp;x)</span> &#123;</span><br><span class="line">    QNode *p;</span><br><span class="line">    <span class="keyword">if</span>(lqu-&gt;rear==<span class="literal">NULL</span>)    <span class="comment">//队空不能出队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p = lqu-&gt;front;</span><br><span class="line">    <span class="keyword">if</span>(lqu-&gt;front==lqu-&gt;rear)    <span class="comment">//队列只有一个结点时出队需特殊处理</span></span><br><span class="line">        lqu-&gt;front = lqu-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        lqu-&gt;front = lqu-&gt;front-&gt;next;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不需要记忆，读程序并理解操作意义即可。尽量采用顺序队解决问题，避免采用链队，除非明确规定。</p>
</blockquote>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="结构体定义-3"><a href="#结构体定义-3" class="headerlink" title="结构体定义"></a>结构体定义</h3><p>可以用以下语句定义一个名为<code>str</code>的串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;abcdef&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>一般不采取这种方式，原因是仅仅以<code>&#39;\0&#39;</code>作为结束标记，在求串长时需要扫描整个串，时间复杂度为O(n)；不如额外定义一个变量存储长度，求串长变成时间复杂度为O(1)的操作。</p>
<h4 id="定长顺序存储"><a href="#定长顺序存储" class="headerlink" title="定长顺序存储"></a>定长顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> str[maxSize+<span class="number">1</span>];    <span class="comment">//多出一个&#x27;\0&#x27;作为结束标记</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; Str;</span><br></pre></td></tr></table></figure>

<h4 id="变长分配存储"><a href="#变长分配存储" class="headerlink" title="变长分配存储"></a>变长分配存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;    <span class="comment">//指向动态分配存储区首地址的字符指针</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; Str;</span><br></pre></td></tr></table></figure>

<p>使用这种存储方式时，需要用函数<code>malloc()</code>来分配一个长度为<code>length</code>、类型为<code>char</code>的连续存储空间。变长分配存储方法有顺序存储结构的特点，操作中串长可根据需要来设定，更加灵活。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>因为串是一个数组，赋值操作不能用<code>=</code>来实现，必须对数组中的每个元素进行逐一赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strassign</span><span class="params">(Str &amp;str, <span class="type">char</span> *ch)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.ch) &#123;</span><br><span class="line">        <span class="built_in">free</span>(str.ch);    <span class="comment">//释放原串空间</span></span><br><span class="line">        str.ch = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *c = ch;</span><br><span class="line">    <span class="keyword">while</span>(*c) &#123;            <span class="comment">//求ch串的长度</span></span><br><span class="line">        len++;</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>) &#123;        <span class="comment">//如果ch为空串，则直接返回空串</span></span><br><span class="line">        str.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        str.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len+<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//取len+1是为了多分配一个空间存放&#x27;\0&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(str.ch==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            c = ch;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=len; i++, c++)</span><br><span class="line">                str.ch[i] = *c;</span><br><span class="line">            <span class="comment">//注意循环条件使用&lt;=来复制&#x27;\0&#x27;到新串中</span></span><br><span class="line">            str.length = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>strassign()</code>使用时格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strassign(str, <span class="string">&quot;cur input&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将<code>&quot;cur input&quot;</code>赋到<code>str</code>串中。执行后，<code>str.ch</code>的值为”cur input”，<code>str.length</code>的值为9。</p>
<h4 id="取串长度"><a href="#取串长度" class="headerlink" title="取串长度"></a>取串长度</h4><p>使用变长分配存储的情况下，直接使用<code>str.length</code>语句即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strlength</span><span class="params">(Str str)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有给出串长度信息的情况下，可以借鉴函数<code>strassign()</code>中的求输入串的长度部分的代码实现。</p>
<h4 id="串比较"><a href="#串比较" class="headerlink" title="串比较"></a>串比较</h4><p>设两串A和B中的待比较字符分别为a和b，如果a的ASCII码大于（小于）b的ASCII码，则返回A大于（小于）B的标记；如果a等于b，则继续比较下一对字符。经过上述步骤没有比较出A和B大小的情况下，先结束的串为较小串，两串同时结束则返回相等标记。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcompare</span><span class="params">(Str s1, Str s2)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s1.length &amp;&amp; i&lt;s2.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(s1.ch[i]!=s2.ch[i])</span><br><span class="line">            <span class="keyword">return</span> s1.ch[i]!=s2.ch[i];</span><br><span class="line">    <span class="keyword">return</span> s1.length - s2.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="串连接"><a href="#串连接" class="headerlink" title="串连接"></a>串连接</h4><p>将两个串首尾相接，合并成一个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">concat</span><span class="params">(Str &amp;str, Str str1, Str str2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.ch) &#123;</span><br><span class="line">        <span class="built_in">free</span>(str.ch);</span><br><span class="line">        str.ch = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (str1.length+str2.length+<span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;str1.length) &#123;</span><br><span class="line">        str.ch[i] = str1.ch[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=str2.length) &#123;    <span class="comment">//注意用&lt;=符号</span></span><br><span class="line">        str.ch[i+j] = str2.ch[j];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    str.length = str1.length + str2.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h4><p>求<code>str</code>串中从<code>pos</code>位置开始，长度为<code>len</code>的子串，子串由<code>substr</code>返回给用户。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">substring</span><span class="params">(Str &amp;substr, Str str, <span class="type">int</span> pos, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">0</span> || pos&gt;=str.length || len&lt;<span class="number">0</span> || len&gt;str.length-pos)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(substr.ch) &#123;</span><br><span class="line">        <span class="built_in">free</span>(substr.ch);</span><br><span class="line">        substr.ch = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>) &#123;</span><br><span class="line">        substr.ch = <span class="literal">NULL</span>;</span><br><span class="line">        substr.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        substr.ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len+<span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> i = pos;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;pos+len) &#123;</span><br><span class="line">            substr.ch[j] = str.ch[i];</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        substr.ch[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        substr.length = len;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="串清空"><a href="#串清空" class="headerlink" title="串清空"></a>串清空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clearstring</span><span class="params">(Str &amp;str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.ch) &#123;</span><br><span class="line">        <span class="built_in">free</span>(str.ch);</span><br><span class="line">        str.ch = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>对一个某子串的定位操作称为串的模式匹配，其中待定位的子串称为模式串。</p>
<blockquote>
<p>串中字符存储在<code>1~length</code>的位置上，注意区分前面的<code>0~length-1</code>的存储位置。</p>
</blockquote>
<h4 id="简单模式匹配算法"><a href="#简单模式匹配算法" class="headerlink" title="简单模式匹配算法"></a>简单模式匹配算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">index</span><span class="params">(Str str, Str substr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>, k=<span class="number">1</span>;    <span class="comment">//串从数组下标1位置开始存储</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=str.length &amp;&amp; k&lt;=substr.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.ch[i]==substr.ch[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">            i = ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;substr.length)</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>令简单模式匹配算法中的主串位置<code>i</code>不需要回溯。</p>
<p>定义一个<code>next[j]</code>数组，表示模式串中第<code>j</code>个字符发生不匹配时，应从<code>next[j]</code>处的字符开始重新与主串的不匹配处进行比较。</p>
<blockquote>
<p>特殊情况：</p>
<ol>
<li><p>模式串中的第一个字符与主串<code>i</code>位置不匹配，从主串的下一字符和模式串的第一个字符继续比较，即从<code>s[i+1]</code>与<code>p[1]</code>开始比较，此时<code>next[1]=0</code>。</p>
</li>
<li><p>前后缀不存在重合部分时，从主串中发生不匹配的字符与模式串的第一个字符继续比较，即从<code>s[i]</code>与<code>p[1]</code>开始比较，此时<code>next[j]=1</code>。</p>
</li>
</ol>
</blockquote>
<p>求<code>next</code>数组的算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getnext</span><span class="params">(Str substr, <span class="type">int</span> next[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>;    <span class="comment">//串从数组下标1位置开始存储</span></span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;substr.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || substr.ch[i]==substr.ch[j]) &#123;</span><br><span class="line">        <span class="comment">//i表示后缀 j表示前缀</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当<code>substr[i-1]==substr[j-1]</code>但<code>substr[i]!=substr[j]</code>时，表示前缀（模式串）中的第<code>j</code>个字符发生不匹配，应从<code>next[j]</code>处的字符开始重新与后缀（主串）比较，即把<code>j</code>的值回溯到<code>next[j]</code>。</p>
</blockquote>
<p>得到<code>next</code>数组后，将简单模式匹配算法稍作修改得到KMP算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(Str str, Str substr, <span class="type">int</span> next[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=str.length &amp;&amp; j&lt;=substr.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || str.ch[i]==substr.ch[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;substr.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>-substr.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP算法的改进"><a href="#KMP算法的改进" class="headerlink" title="KMP算法的改进"></a>KMP算法的改进</h4><p>求<code>nextval</code>的一般步骤：</p>
<ol>
<li><p>当<code>j</code>等于<code>1</code>时，<code>next[j]</code>赋值为<code>0</code>。</p>
</li>
<li><p>当<code>p[j]</code>不等于<code>p[k]</code>(<code>k = next[j]</code>)，<code>nextva[j]</code>赋值为<code>next[j]</code>。</p>
</li>
<li><p>当<code>p[j]</code>等于<code>p[k]</code>(<code>k = next[j]</code>)，<code>nextva[j]</code>赋值为<code>nextval[next[j]]</code>。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getnextval</span><span class="params">(Str substr, <span class="type">int</span> nextval[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;substr.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || substr.ch[i]==substr.ch[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(substr.ch[i] != substr.ch[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><blockquote>
<p>非空二叉树上<strong>叶子结点</strong>数等于<strong>双分支结点</strong>数加1。</p>
<p>总分支数&#x3D;总结点数-1（对任何树都适用）</p>
<p>n0&#x3D;1+n2+2n3+…+(m-1)nm</p>
</blockquote>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><table>
<thead>
<tr>
<th>结点</th>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody><tr>
<td>数组下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>用一个数组<code>BTree[]</code>来存储一棵二叉树，最适合<strong>完全二叉树</strong>。例如，得到A的左孩子结点只需访问<code>BTree[1*2]</code>即可。类似地，如果知道了一个结点<code>i</code>，如果<code>2i</code>不大于<code>n</code>，则<code>i</code>的左孩子结点就存在<code>BTree[2*i]</code>内。</p>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的遍历算法"><a href="#二叉树的遍历算法" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preorder</span><span class="params">(BTNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        Visit(p);</span><br><span class="line">        preorder(p-&gt;lchild);</span><br><span class="line">        preorder(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preorderNonrecursion</span><span class="params">(BTNode *bt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(bt!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        BTNode *Stack[maxSize];       <span class="comment">//定义一个栈</span></span><br><span class="line">        <span class="type">int</span> top=<span class="number">-1</span>;                   <span class="comment">//初始化栈</span></span><br><span class="line">        BTNode *p;</span><br><span class="line">        Stack[++top] = bt;            <span class="comment">//根结点入栈</span></span><br><span class="line">        <span class="keyword">while</span>(top!=<span class="number">-1</span>) &#123;              <span class="comment">//栈空遍历结束</span></span><br><span class="line">            p = Stack[top--];         <span class="comment">//出栈并输出栈顶结点</span></span><br><span class="line">            Visit(p);                 <span class="comment">//访问p</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)       <span class="comment">//栈顶结点的右孩子存在则右孩子入栈</span></span><br><span class="line">                Stack[++top] = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)       <span class="comment">//栈顶结点的左孩子存在则左孩子入栈</span></span><br><span class="line">                Stack[++top] = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(BTNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        inorder(p-&gt;lchild);</span><br><span class="line">        Visit(p);</span><br><span class="line">        inorder(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inorderNonrecursion</span><span class="params">(BTNode *bt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(bt!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        BTNode *Stack[maxSize]; <span class="type">int</span> top=<span class="number">-1</span>;</span><br><span class="line">        BTNode *p;</span><br><span class="line">        p = bt;</span><br><span class="line">        <span class="comment">/*以下循环完成中序遍历，注意根结点出栈后会出现栈空，但遍历还未结束*/</span></span><br><span class="line">        <span class="keyword">while</span>(top!=<span class="number">-1</span> || p!=<span class="literal">NULL</span>) &#123; <span class="comment">//根结点的右子树还未遍历时p非空</span></span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="literal">NULL</span>) &#123;        <span class="comment">//左孩子存在，则左孩子入栈</span></span><br><span class="line">                Stack[++top] = p;</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top!=<span class="number">-1</span>) &#123;           <span class="comment">//栈不空的情况下出栈并输出</span></span><br><span class="line">                p = Stack[top--];</span><br><span class="line">                Visit(p);</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>递归</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postorder</span><span class="params">(BTNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        postorder(p-&gt;lchild);</span><br><span class="line">        postorder(p-&gt;rchild);</span><br><span class="line">        Visit(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归</p>
<p>逆后续遍历序列是先序遍历序列过程中<strong>交换左右子树遍历顺序</strong>得到的结果。需要两个栈，<code>stack1</code>用来辅助做逆后序遍历（交换先序遍历的左右子树遍历顺序），并将遍历结果序列压入<code>stack2</code>，然后将<code>stack2</code>的元素全部出栈，所得即为后续遍历序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postorderNonrecursion</span><span class="params">(BTNode *bt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(bt!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/*定义两个栈*/</span></span><br><span class="line">        BTNode *Stack1[maxSize]; <span class="type">int</span> top1=<span class="number">-1</span>;</span><br><span class="line">        BTNode *Stack2[maxSize]; <span class="type">int</span> top2=<span class="number">-1</span>;</span><br><span class="line">        BTNode *p = <span class="literal">NULL</span>;</span><br><span class="line">        Stack1[++top1] = bt;</span><br><span class="line">        <span class="keyword">while</span>(top1!=<span class="number">-1</span>) &#123;</span><br><span class="line">            p = Stack1[top1--];</span><br><span class="line">            Stack2[++top2] = p;</span><br><span class="line">            <span class="comment">/*以下两个if语句与先序遍历相反*/</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">                Stack1[++top1] = p-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">                Stack1[++top1] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(top2!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = Stack2[top2--];</span><br><span class="line">            Visit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">level</span><span class="params">(BTNode *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    BTNode *que[maxSize];        <span class="comment">//循环队列记录将要访问层次上的结点</span></span><br><span class="line">    front = rear = <span class="number">0</span>;</span><br><span class="line">    BTNode *q;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        rear = (rear+<span class="number">1</span>) % maxSize;</span><br><span class="line">        que[rear] = p;           <span class="comment">//根结点入队</span></span><br><span class="line">        <span class="keyword">while</span>(front!=rear) &#123;     <span class="comment">//队列不空时循环</span></span><br><span class="line">            front = (front+<span class="number">1</span>) % maxSize;</span><br><span class="line">            q = que[front];      <span class="comment">//队头结点出队</span></span><br><span class="line">            Visit(q);</span><br><span class="line">            <span class="comment">/*以下两个if表示如果左右子树不空，则左右子树的根结点入队*/</span></span><br><span class="line">            <span class="keyword">if</span>(q-&gt;lchild!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">                rear = (rear+<span class="number">1</span>) % maxSize;</span><br><span class="line">                que[rear] = q-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;rchild!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">                rear = (rear+<span class="number">1</span>) % maxSize;</span><br><span class="line">                que[rear] = q-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="结构体定义-4"><a href="#结构体定义-4" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TBTNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TBTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TBTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; TBTNode;</span><br></pre></td></tr></table></figure>

<h4 id="中序线索二叉树"><a href="#中序线索二叉树" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h4><p>通过中序遍历对二叉树线索化的递归算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(TBTNode *p, TBTNode *&amp;pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        InThread(p-&gt;rchild, pre);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        InThread(p-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每当访问一个结点时，如果其左指针为空，就把该指针指向其前驱结点；如果前驱结点的右指针为空，就把该指针指向当前访问结点。</p>
</blockquote>
<p>通过中序遍历建立中序线索二叉树的主程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">createInThread</span><span class="params">(TBTNode *root)</span> &#123;</span><br><span class="line">    TBTNode *pre = <span class="literal">NULL</span>;        <span class="comment">//第一个前驱结点指针，处理中序第一个结点的左指针</span></span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        InThread(root, pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;     <span class="comment">//线索化后，处理中序最后一个结点的右指针</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历中序线索二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一个结点的算法*/</span></span><br><span class="line">TBTNode *<span class="title function_">First</span><span class="params">(TBTNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">        p = p-&gt;lchild;        <span class="comment">//最左下结点（不一定是叶结点）</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*后继结点的算法*/</span></span><br><span class="line">TBTNode *<span class="title function_">Next</span><span class="params">(TBTNode *p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> First(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;    <span class="comment">//rtag==1，直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*执行中序遍历*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(TBTNode *root)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(TBTNode *p=First(root); p!=<span class="literal">NULL</span>; p=Next(p))</span><br><span class="line">        Visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树和森林与二叉树的转换"><a href="#树和森林与二叉树的转换" class="headerlink" title="树和森林与二叉树的转换"></a>树和森林与二叉树的转换</h3><h4 id="树与二叉树的相互转换"><a href="#树与二叉树的相互转换" class="headerlink" title="树与二叉树的相互转换"></a>树与二叉树的相互转换</h4><p>手工转换。</p>
<p>左指针（child）指向孩子，右指针指向兄弟（sibling）。</p>
<h4 id="森林与二叉树的相互转换"><a href="#森林与二叉树的相互转换" class="headerlink" title="森林与二叉树的相互转换"></a>森林与二叉树的相互转换</h4><p>手工转换。</p>
<p>根结点的右孩子指针指向森林中的下一棵树。</p>
<h4 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h4><p>只有<strong>先序遍历</strong>（先根再子树）和<strong>后序遍历</strong>（先子树再根）。</p>
<p>树或森林转换为二叉树后，先序遍历对应二叉树的先序遍历，后序遍历对应二叉树的中序遍历。</p>
<h3 id="赫夫曼树和赫夫曼编码"><a href="#赫夫曼树和赫夫曼编码" class="headerlink" title="赫夫曼树和赫夫曼编码"></a>赫夫曼树和赫夫曼编码</h3><p>带权路径长度：从该结点到根之间的路径长度乘以结点的权值。</p>
<p>树的带权路径长度（WPL）是树中所有叶子结点的带权路径长度之和。</p>
<p>赫夫曼树的特点：</p>
<ol>
<li><p>权值越大的结点离根结点越近。</p>
</li>
<li><p>没有度为1的结点。又叫做正则（严格）二叉树。</p>
</li>
<li><p>带权路径长度最短。</p>
</li>
</ol>
<h4 id="构造赫夫曼树"><a href="#构造赫夫曼树" class="headerlink" title="构造赫夫曼树"></a>构造赫夫曼树</h4><p>手工构造。</p>
<blockquote>
<p>注意：每次都选出根结点最小的两棵树构造新的二叉树，其中不一定包括上一步构造的二叉树。</p>
</blockquote>
<h4 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h4><p>手工编码，对赫夫曼树的每个结点的左右分支进行编号，左0右1。</p>
<p>赫夫曼编码产生<strong>最短前缀码</strong>：</p>
<ul>
<li><p>前缀码：根通往任一叶子结点的路径都不是通往其余叶子结点路径的子路径，因此任一字符的编码串都不是另一字符编码串的前缀。</p>
</li>
<li><p>最短：每个字符的权值是其出现次数，出现次数越多的字符编码长度越短，因此整个字符串编码后的前缀码长度最短。</p>
</li>
</ul>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> no;                     <span class="comment">//顶点编号</span></span><br><span class="line">    <span class="type">char</span> info;                  <span class="comment">//其他信息，无特殊要求不写</span></span><br><span class="line">&#125; VertexType;                   <span class="comment">//顶点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                <span class="comment">//图的定义</span></span><br><span class="line">    <span class="type">int</span> edges[maxSize][maxSize];</span><br><span class="line">    <span class="comment">//邻接矩阵定义，如果是有权图，将int改成float</span></span><br><span class="line">    <span class="type">int</span> n, e;                   <span class="comment">//顶点和边数</span></span><br><span class="line">    VertexType vex[maxSize];    <span class="comment">//存放顶点信息</span></span><br><span class="line">&#125; MGraph;                       <span class="comment">//图的邻接矩阵类型</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果明确说明采用邻接矩阵表示，并且要求写出邻接矩阵定义，则上述代码全写。</p>
</li>
<li><p>如果没有要求写出邻接矩阵定义，只是说图采用邻接矩阵表示，则不许写出以上代码。但需记住，因为解题中要引用结构体的各成员。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(MGraph G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = G.n;</span><br><span class="line">    <span class="type">int</span> b = G.e;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>f()</code>的参数是一个表示图的结构体变量<code>G</code>。例如，若要取图的顶点数赋值给<code>a</code>，就可以写成<code>a=G.n</code>；若要检测编号为<code>i</code>的顶点和编号为<code>j</code>的顶点是否邻接，则看<code>G.edges[i][j]</code>是否等于1。</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;                   <span class="comment">//该边所指向顶点位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span>      <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="type">int</span> info;                     <span class="comment">//相关信息（如权值），无特殊要求不写</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;                    <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;            <span class="comment">//指向第一条边的指针</span></span><br><span class="line">&#125; VNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VNode adjlist[maxSize];       <span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> n, e;                     <span class="comment">//顶点数和边数</span></span><br><span class="line">&#125; AGraph;                         <span class="comment">//图的邻接表类型</span></span><br></pre></td></tr></table></figure>

<h3 id="图的遍历算法"><a href="#图的遍历算法" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h3><h4 id="深度优先搜索遍历DFS"><a href="#深度优先搜索遍历DFS" class="headerlink" title="深度优先搜索遍历DFS"></a>深度优先搜索遍历DFS</h4><p>算法执行过程：任取一个顶点，访问之，然后检查这个顶点的所有邻接顶点，递归访问其中未被访问过的顶点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visit[maxSize];</span><br><span class="line"><span class="comment">/*v是起点编号，visit[]是一个全局数组，作为顶点的访问标记，初始为0*/</span></span><br><span class="line"><span class="comment">/*图中可能存在回路，要对每个顶点进行标记，以免重复访问*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(AGraph *G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    visit[v] = <span class="number">1</span>;                  <span class="comment">//已访问标记</span></span><br><span class="line">    Visit(v);                      <span class="comment">//访问操作</span></span><br><span class="line">    p = G-&gt;adjlist[v].firstarc;    <span class="comment">//p指向v的第一条边</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[p-&gt;adjvex]==<span class="number">0</span>)    <span class="comment">//若顶点还未访问则递归访问它</span></span><br><span class="line">            DFS(G, p-&gt;adjvex);</span><br><span class="line">        p = p-&gt;nextarc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为<code>O(n+e)</code>。</p>
<h4 id="广度优先搜索遍历"><a href="#广度优先搜索遍历" class="headerlink" title="广度优先搜索遍历"></a>广度优先搜索遍历</h4><p>算法执行过程：</p>
<ol>
<li><p>任取图中一个顶点访问，入队，并将这个顶点标记为已访问。</p>
</li>
<li><p>当队列不空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队。</p>
</li>
<li><p>当队列为空时跳出循环，广度优先搜索完成。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(AGraph *G, <span class="type">int</span> v, <span class="type">int</span> visit[maxSize])</span> &#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> que[maxSize], front=<span class="number">0</span>, rear=<span class="number">0</span>;            <span class="comment">//队列定义的简单写法</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    Visit(v);</span><br><span class="line">    visit[v] = <span class="number">1</span>;</span><br><span class="line">    rear = (rear+<span class="number">1</span>) % maxSize;                    <span class="comment">//当前顶点v进队</span></span><br><span class="line">    que[rear] = v;</span><br><span class="line">    <span class="keyword">while</span>(front!=rear) &#123;</span><br><span class="line">        front = (front+<span class="number">1</span>) % maxSize;              <span class="comment">//顶点出队</span></span><br><span class="line">        j = que[front];</span><br><span class="line">        p = G-&gt;adjlist[j].firstarc;               <span class="comment">//p指向出队顶点j的第一条边</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[p-&gt;adjvex]==<span class="number">0</span>) &#123;             <span class="comment">//邻接顶点未被访问则入队</span></span><br><span class="line">                Visit(p-&gt;adjvex);</span><br><span class="line">                visit[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">                rear = (rear+<span class="number">1</span>) % maxSize;        <span class="comment">//该顶点入队</span></span><br><span class="line">                que[rear] = p-&gt;adjvex;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nextarc;                       <span class="comment">//p指向j的下一条边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为<code>O(n+e)</code>。</p>
<h3 id="最小（代价）生成树"><a href="#最小（代价）生成树" class="headerlink" title="最小（代价）生成树"></a>最小（代价）生成树</h3><h4 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h4><p>从图中选取一个顶点，把它当成一棵树，然后从<strong>与这棵树相接的边</strong>中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到一棵有2个顶点的树。然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入当前树中，得到一棵有3个顶点的树。以此类推，直到图中所有顶点都并入树中为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Prim</span><span class="params">(MGraph g, <span class="type">int</span> v0, <span class="type">int</span> &amp;sum)</span> &#123;</span><br><span class="line">    <span class="type">int</span> lowcost[maxSize], vset[maxSize], v;</span><br><span class="line">    <span class="type">int</span> i, j, k, min;</span><br><span class="line">    v = v0;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g.n; i++) &#123;</span><br><span class="line">        lowcost[i] = g.edges[v0][i];</span><br><span class="line">        vset[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vset[v0] = <span class="number">1</span>;             <span class="comment">//将v0并入树中</span></span><br><span class="line">    sum = <span class="number">0</span>;                  <span class="comment">//sum清零用来累计树的权值</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g.n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        min = INF;            <span class="comment">//INF是已定义的足够大的常量</span></span><br><span class="line">        <span class="comment">/*以下循环选出侯选边中的最小者*/</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;g.n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vset[j]==<span class="number">0</span> &amp;&amp; lowcost[j]&lt;min) &#123;</span><br><span class="line">                <span class="comment">/*选出当前生成树到其余顶点最短边中最短的一条*/</span></span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vset[k] = <span class="number">1</span>;</span><br><span class="line">        v = k;</span><br><span class="line">        sum += min;            <span class="comment">//记录最小生成树的权值</span></span><br><span class="line">        <span class="comment">/*以下循环以刚并入的顶点v为媒介更新侯选边*/</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;g.n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vset[j]==<span class="number">0</span> &amp;&amp; g.edges[v][j]&lt;lowcost[j])</span><br><span class="line">                lowcost[j] = g.edges[v][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普里姆算法的时间复杂度为<code>O(n²)</code>。</p>
<h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><p>每次找出侯选边中权值最小的边，就将该边并入生成树中。重复此过程直到所有边都被检测完为止。检测当前边是否为候选边，即判断该边的并入是否会构成回路，如不构成回路，则将该边并入生成树中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a, b;                    <span class="comment">//一条边所连的两个顶点</span></span><br><span class="line">    <span class="type">int</span> w;                       <span class="comment">//边的权值</span></span><br><span class="line">&#125; Road;</span><br><span class="line">Road road[maxSize];</span><br><span class="line"><span class="type">int</span> v[maxSize];                  <span class="comment">//定义并查集数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRoot</span><span class="params">(<span class="type">int</span> a)</span> &#123;             <span class="comment">//在并查集中查找根结点的函数</span></span><br><span class="line">    <span class="keyword">while</span>(a != v[a])</span><br><span class="line">        a = v[a];</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kruskal</span><span class="params">(MGraph g, <span class="type">int</span> &amp;sum, Road road[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> N, E, a, b;</span><br><span class="line">    N = g.n;</span><br><span class="line">    E = g.e;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)</span><br><span class="line">        v[i] = i;</span><br><span class="line">    sort(road, E);               <span class="comment">//对road数组中的E条边按权值从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;E; i++) &#123;</span><br><span class="line">        a = getRoot(road[i].a);</span><br><span class="line">        b = getRoot(road[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a!=b) &#123;</span><br><span class="line">            v[a] = b;</span><br><span class="line">            sum += road[i].w;    <span class="comment">//求生成树的权值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>克鲁斯卡尔算法的时间复杂度主要由选取的排序算法<code>sort()</code>决定。排序算法处理数据的规模由图的边数<code>E</code>决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图。</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h4><p>手工求解</p>
<p>已并入顶点 | 剩余顶点 | dist[] | path[]</p>
<p>时间复杂度为<code>O(n²)</code>。</p>
<h4 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h4><p>手工求解</p>
<p>十字交叉法</p>
<p>A-1-A3 | Path-1-Path3</p>
<p>时间复杂度为<code>O(n³)</code>。</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>手工排序</p>
<p>时间复杂度为<code>O(n+e)</code>，其中<code>n</code>为顶点个数，<code>e</code>为边的条数。</p>
<h3 id="最短路径-1"><a href="#最短路径-1" class="headerlink" title="最短路径"></a>最短路径</h3><ol>
<li><p>根据图求出拓扑有序序列a和逆拓扑有序序列b。</p>
</li>
<li><p>根据a和b分别求出每个事件（顶点）的最早发生时间<code>ve()</code>和最迟发生时间<code>vl()</code>。</p>
</li>
<li><p>根据2中结果求出每个活动（边）的最早发生时间<code>e()</code>和最迟发生时间<code>l()</code>。</p>
</li>
<li><p>根据3中结果找出最早发生时间和最迟发生时间相同的活动，即为关键活动。由关键活动所连成的路径即为关键路径。</p>
</li>
</ol>
<p>活动 | 最早发生时间 | 最迟发生时间 | 关键活动</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote>
<p>以下算法基于非递减排序。</p>
</blockquote>
<h3 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> n)</span> &#123;   <span class="comment">//待排关键字存于R[]中，个数为n</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        temp = R[i];                <span class="comment">//待插入关键字暂存于temp</span></span><br><span class="line">        j = i<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/*以下循环完成从待排关键字前一位开始扫描，如果大于待排关键字则后移一位*/</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;R[j]) &#123;</span><br><span class="line">            R[j+<span class="number">1</span>] = R[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        R[j+<span class="number">1</span>] = temp;              <span class="comment">//找到新插入位置，将temp暂存的待排关键字插入</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：最坏<code>O(n²)</code>，最好<code>O(n)</code>，平均<code>O(n²)</code>。空间复杂度：<code>O(1)</code>。</p>
<h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>采用折半查找法来确定插入位置，基本条件是序列已经有序。</p>
<p>时间复杂度：最坏<code>O(n²)</code>，最好<code>O(nlog₂n)</code>，平均<code>O(n²)</code>。空间复杂度：<code>O(1)</code>。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>手写每一趟排序的执行情况。</p>
<p>时间复杂度与增量选取有关，平均<code>O(nlog₂n)</code>。增量序列的值尽量没有除1以外的公因子，最后一定取1。空间复杂度为<code>O(1)</code>。<strong>不稳定</strong>。</p>
<h3 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h3><h4 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, flag;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;              <span class="comment">//标记本趟排序是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(R[j<span class="number">-1</span>]&gt;R[j]) &#123;</span><br><span class="line">                temp = R[j];</span><br><span class="line">                R[j] = R[j<span class="number">-1</span>];</span><br><span class="line">                R[j<span class="number">-1</span>] = temp;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)            <span class="comment">//一趟排序过程没有发生交换，则序列有序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：最坏<code>O(n²)</code>，最好<code>O(n)</code>，平均<code>O(n²)</code>。空间复杂度：<code>O(1)</code>。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="type">int</span> i=low, j=high;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high) &#123;</span><br><span class="line">        temp = R[low];              <span class="comment">//通常取第一个作为枢纽</span></span><br><span class="line">        <span class="comment">/*以下循环完成一趟排序*/</span></span><br><span class="line">        <span class="comment">/*小于temp的关键字放在左边，大于temp的关键字放在右边*/</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;i &amp;&amp; R[j]&gt;=temp)<span class="comment">//从右往左扫描，找到一个小于temp的关键字</span></span><br><span class="line">                j--;</span><br><span class="line">            <span class="comment">/*以下if判断用于确保退出以上while循环的条件是找到更小的关键字而非i==j*/</span></span><br><span class="line">            <span class="comment">/*当i==j时，i不可再右移，这将导致temp的最终位置R[i]错误地右偏一位*/</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;j) &#123;</span><br><span class="line">                R[i] = R[j];        <span class="comment">//放在temp最终位置的左边</span></span><br><span class="line">                i++;                <span class="comment">//i右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; R[i]&lt;temp) <span class="comment">//从左往右扫描，找到一个大于等于temp的关键字</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j) &#123;</span><br><span class="line">                R[j] = R[i];        <span class="comment">//放在temp最终位置的右边</span></span><br><span class="line">                j--;                <span class="comment">//j右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        R[i] = temp;                <span class="comment">//将temp放在最终位置</span></span><br><span class="line">        QuickSort(R, low, i<span class="number">-1</span>);     <span class="comment">//递归地对temp左边的关键字进行排序</span></span><br><span class="line">        QuickSort(R, i+<span class="number">1</span>, high);    <span class="comment">//递归地对temp右边的关键字进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：最坏<code>O(n²)</code>，最好<code>O(nlog₂n)</code>，平均<code>O(nlog₂n)</code>。空间复杂度：<code>O(log₂n)</code>。<strong>不稳定</strong>。</p>
<h3 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="comment">/*以下循环从无序序列中挑出最小的关键字*/</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>; i&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(R[k]&gt;R[j])</span><br><span class="line">                k = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*以下3句完成最小关键字与无序序列第一个关键字的交换交换*/</span></span><br><span class="line">        temp = R[i];</span><br><span class="line">        R[i] = R[k];</span><br><span class="line">        R[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n²)</code>，与初始序列无关。空间复杂度：<code>O(1)</code>。</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>手工建堆、排序。</p>
<ol>
<li><p>从无序序列所确定的完全二叉树的最后一个非叶节点开始，从右往左，从下往上，对每个结点进行调整，得到一个大顶堆。（向下调整）</p>
</li>
<li><p>将当前无序序列中的第一个关键字a（根结点）与最后一个关键字b（最后一个叶子结点）交换。无序序列关键字减少1个，有序序列关键字增加1个。此时只有b可能不满足堆的定义，对其进行调整。</p>
</li>
<li><p>重复第2步，直到无序序列的关键字只剩1个。</p>
</li>
</ol>
<p>插入结点：放在最底层的最右边，然后向上调整。</p>
<p>删除结点：把最底层最右边的叶子的值赋给删除位置，然后向下调整。</p>
<p>时间复杂度：<code>O(nlog₂n)</code>，即使在最坏情况下。这是相对于快速排序最大的优点。</p>
<p>空间复杂度：<code>O(1)</code>，在所有时间复杂度为<code>O(nlog₂n)</code>的排序中是最小的。</p>
<h3 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> n1 = mid-low+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = high-mid;</span><br><span class="line">    <span class="type">int</span> L[n1], R[n2];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n1; i++)</span><br><span class="line">        L[i] = arr[low+i];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n2; j++)</span><br><span class="line">        R[j] = arr[mid+<span class="number">1</span>+j];</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    k = low;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n1 &amp;&amp; j&lt;n2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i]&lt;=R[j])</span><br><span class="line">            arr[k] = L[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            arr[k] = R[j++];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n1)</span><br><span class="line">        arr[k++] = L[i++];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n2)</span><br><span class="line">        arr[k++] = R[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(A, low, mid);        <span class="comment">//归并排序前半段</span></span><br><span class="line">        mergeSort(A, mid+<span class="number">1</span>, high);     <span class="comment">//归并排序后半段</span></span><br><span class="line">        merge(A, low, mid, high);</span><br><span class="line">        <span class="comment">//merge()把A数组中low到mid和mid+1到high的两段有序序列归并成一段有序序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(nlog₂n)</code>，与初始序列无关 。空间复杂度：<code>O(n)</code>。</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>手工分配收集。</p>
<p>时间复杂度：O(d(n+rd))</p>
<p>空间复杂度：O(rd)</p>
<p>n为序列中的关键字数；d为关键字的位数（如930由3位组成，d&#x3D;3）；rd为关键字基的个数，如关键字为十进制数值时，rd&#x3D;10。</p>
<blockquote>
<p>基数排序适合关键字很多，但关键字基较小的序列。如数字0~9是可以接受的，但如果是26个字母而且大多数关键字的最高位不相同，可以考虑“最高位优先”法。</p>
</blockquote>
<h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><h3 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==k)</span><br><span class="line">            <span class="keyword">return</span> i;        <span class="comment">//查找成功返回i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                <span class="comment">//查找失败返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(n)</code>。</p>
<h3 id="折半查找法"><a href="#折半查找法" class="headerlink" title="折半查找法"></a>折半查找法</h3><p>迭代版：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Bsearch</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high) &#123;            <span class="comment">//子表长度大于等于1时循环</span></span><br><span class="line">        mid = (low+high) / <span class="number">2</span>;     <span class="comment">//取当前表的中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(R[mid]==k)</span><br><span class="line">            <span class="keyword">return</span> mid;           <span class="comment">//找到后返回元素的位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(R[mid]&gt;k)</span><br><span class="line">            high = mid - <span class="number">1</span>;       <span class="comment">//继续在R[low, ..., mid-1]中查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;        <span class="comment">//继续在R[mid+1, ..., high]中查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                    <span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归版：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Bsearch</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;                               <span class="comment">//未找到，返回-1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(R[mid]==k)</span><br><span class="line">            <span class="keyword">return</span> mid;                          <span class="comment">//找到，返回下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(R[mid]&gt;k)</span><br><span class="line">            <span class="keyword">return</span> Bsearch(R, low, mid<span class="number">-1</span>, k);    <span class="comment">//在左段中查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Bsearch(R, mid+<span class="number">1</span>, high, k);   <span class="comment">//在右段中查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：<code>O(log₂n)</code>。</p>
<p>建立折半查找判定树，求平均查找长度。</p>
<h3 id="二叉排序树（二叉查找树）"><a href="#二叉排序树（二叉查找树）" class="headerlink" title="二叉排序树（二叉查找树）"></a>二叉排序树（二叉查找树）</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>采用二叉链表进行存储，结点类型定义与一半的二叉树类似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;        <span class="comment">//将data改为key，代表关键字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure>

<h4 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h4><p><strong>查找关键字</strong></p>
<p>与折半查找法相似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BTNode *<span class="title function_">BSTSearch</span><span class="params">(BTNode *bt, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(key == bt-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> bt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; bt-&gt;key)    <span class="comment">//到左子树查找</span></span><br><span class="line">            <span class="keyword">return</span> BSTSearch(bt-&gt;lchild, key);</span><br><span class="line">        <span class="keyword">else</span>                    <span class="comment">//到右子树查找</span></span><br><span class="line">            <span class="keyword">return</span> BSTSearch(bt-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入关键字</strong></p>
<p>首先要找到插入位置。对于一个不存在于二叉排序树中的关键字，查找不成功的位置即为插入位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTInsert</span><span class="params">(BTNode *&amp;bt, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>) &#123;            <span class="comment">//空指针说明找到插入位置，创建新结点进行插入</span></span><br><span class="line">        bt = (BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));    <span class="comment">//创建新结点</span></span><br><span class="line">        bt-&gt;lchild = bt-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        bt-&gt;key = key;        <span class="comment">//将待插关键字存入新节点内，插入成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                    <span class="comment">//结点不空则查找插入位置，与查找算法类似</span></span><br><span class="line">        <span class="keyword">if</span>(key == bt-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;        <span class="comment">//已在树中，插入失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; bt-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> BSTInsert(bt-&gt;lchild, key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> BSTInsert(bt-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造二叉排序树</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateBST</span><span class="params">(BTNode *&amp;bt, <span class="type">int</span> key[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    bt = <span class="literal">NULL</span>;                <span class="comment">//将树清空</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)        <span class="comment">//调用接口函数，逐个插入</span></span><br><span class="line">        BSTInsert(bt, key[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除关键字</strong></p>
<p>手工操作。</p>
<p>删除<code>p</code>结点：</p>
<ol>
<li><p><code>p</code>结点为叶子结点。直接删除即可。</p>
</li>
<li><p><code>p</code>结点只有左子树，或者只有右子树。将<code>p</code>删掉，并将<code>p</code>的子树直接连接在<code>p</code>与其双亲相连的指针上。</p>
</li>
<li><p><code>p</code>结点既有左子树又有右子树。沿着<code>p</code>的左子树根结点的右指针一直往右走，直到来到其右子树的最右边一个结点<code>r</code>，然后将<code>p</code>中的关键字用<code>r</code>中的关键字代替。最后判断，如果<code>r</code>是叶子结点，就按照1的方法删除；如果<code>r</code>是非叶子节点，就用2的方法删除。</p>
</li>
</ol>
<h3 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h3><p>平衡二叉树是一种特殊的二叉排序树，其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。</p>
<p><strong>平衡调整</strong></p>
<p>调整失去平衡的<strong>最小子树</strong>。（任一子树不平衡就需调整）</p>
<ul>
<li><p>LL调整（右单旋转调整）</p>
</li>
<li><p>RR调整（左单旋转调整）</p>
</li>
<li><p>LR调整（先左后右双旋转调整）</p>
</li>
<li><p>RL调整（先右后左双旋转调整）</p>
</li>
</ul>
<p>删除结点操作与二叉排序树一致。</p>
<blockquote>
<p>设Nh表示高度为h的平衡二叉树的最少结点数，则有</p>
<p>N0&#x3D;0, N1&#x3D;1, N2&#x3D;2, …, Nh&#x3D;Nh-1+Nh-2+1</p>
</blockquote>
<h3 id="B-树（B树）"><a href="#B-树（B树）" class="headerlink" title="B-树（B树）"></a>B-树（B树）</h3><p>基本概念。</p>
<p>查找、插入、删除操作。</p>
<p>B+树基本概念。</p>
<h3 id="散列表（Hash表）"><a href="#散列表（Hash表）" class="headerlink" title="散列表（Hash表）"></a>散列表（Hash表）</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ol>
<li><p>直接定位法</p>
</li>
<li><p>数字分析法</p>
</li>
<li><p>平方取中法</p>
</li>
<li><p><strong>除留余数法</strong>：p选择小于等于表长的最大素数</p>
</li>
</ol>
<h4 id="冲突处理方法"><a href="#冲突处理方法" class="headerlink" title="冲突处理方法"></a>冲突处理方法</h4><ol>
<li><p>开放定址法</p>
<p>以发生冲突的Hash地址为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。</p>
<ol>
<li><p>线性探查法：<code>d+1 d+2 ... d+m-1</code> 容易产生堆积问题。</p>
</li>
<li><p>平方探查法：<code>d+1² d-1² d+2² d-2² ...</code> 可以减少堆积问题的出现，不能探查到Hash表上的所有单元，但至少能探测到一半单元。</p>
</li>
</ol>
</li>
<li><p>链地址法</p>
<p>把所有同义词用单链表连接起来。</p>
</li>
</ol>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><strong>查找成功</strong>时的平均查找长度是指<strong>找到表中已有表项的平均比较次数</strong>（分母是关键字个数）；</p>
<p><strong>查找不成功</strong>时的平均查找长度是指在表中找不到待查的表项，但<strong>找到插入位置</strong>的平均比较次数（分母是表长度）。</p>
<p><strong>装填因子</strong>是关键字个数与表长度的比值。</p>

                    </article>
                    



<p class="post-footer-info mb-0 pt-0">本文发表于&nbsp;<time datetime="2023-02-09T16:54:50.000Z" itemprop="datePublished">2023-02-10</time>

    , 最后修改于&nbsp;<time datetime="2023-03-12T17:00:22.867Z" itemprop="dateModified">2023-03-13</time>

</p>
<p class="post-footer-info mb-0 pt-2">




</p>

                </div>
                <div class="post-nav px-2 bg-gray">
<ul class="pagination">
    <!-- Prev Nav -->
    

    <!-- Next Nav -->
    
        <li class="page-item page-next">
            <a href="/2023/hello-world/" rel="next">
                <div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">Hello World</div>
            </a>
        </li>
    
</ul>
</div>

                
                    <!-- # Comment # -->
                    
                
            </div>
        </div>
    </div>
</div>

            <!-- ### Footer ### -->
            <footer class="text-center">
    <!-- footer copyright -->
    
        <p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span>
            <a class="footer-copyright-a" href="https://idealisti.github.io">Idealisti</a>
        </p>

    <!-- footer custom text -->
    <p class="footer-text mb-0">
    
    </p>
    <!-- footer develop info -->
    <p class="footer-develop mb-0">
        
    <!-- Busuanzi User Views -->
    <span id="busuanzi_container_site_uv" hidden>
        <span></span>
        <span id="busuanzi_value_site_uv"></span>
        <span>Viewers</span>
        
            <span>|</span>
        
    </span>




        
        Powered by&nbsp;<!--
         --><a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a><span class="footer-develop-divider"></span>Theme&nbsp;-&nbsp;<!--
         --><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" class="footer-develop-a" rel="external noopener">Suka</a>
    </p>
</footer>


        <!-- ### Import File ### -->
        <!-- ### Footer JS Import ### -->

<script>

    
window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 50
};
document.getElementById('copyright-year').textContent = new Date().getFullYear();
console.log('\n %c Suka Theme (hexo-theme-suka) | © SukkaW | Verision 1.3.3 %c https://github.com/SukkaW/hexo-theme-suka \n', 'color: #fff; background: #444; padding:5px 0;', 'background: #bbb; padding:5px 0;');

</script>

<script src="/lib/vanilla-lazyload/lazyload.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


<!-- Offset -->




<!-- Comment -->


<!-- ### Custom Footer ### -->

    </body>

</html>