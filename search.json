[{"title":"数据结构","date":"2023-02-09T16:54:50.000Z","url":"/2023/Data-Structure/","content":"我的数据结构笔记。 线性表线性表的结构体定义顺序表结构体定义 实际中用得较多的非结构体方法（更简洁）： 定义了一个长度为n、表内元素为整数的顺序表。 单链表结点定义 双链表结点定义 构造链表结点时定义一个指针来存储这片空间的地址（即指针指向节点），并常用这个指针的名称来作为结点的名称，例如： LNode *A = (LNode *)malloc(sizeof(LNode)); 顺序表的操作按元素值查找在顺序表L中查找第一个值等于e的元素，并返回下标。 插入数据元素在顺序表L的p (0≤p≤length)位置插入新的元素e。p输入不正确返回0，插入操作成功返回1。 删除数据元素删除顺序表下标为p (0≤p≤length-1)的元素，成功返回1，否则返回0，并将被删除元素的值赋给e。 单链表的操作建立单链表假设有n个元素已经存储在数组a中，用尾插法建立链表C。 用头插法建立链表C。 插入与删除结点假设p指向一个结点，要将s所指结点插入p所指结点之后。 删除第i个结点，需找到第i-1个结点p（注意要释放内存空间）。 归并A和B是两个单链表（带头结点），元素递增有序，将A和B归并成一个按元素递增的链表C，C由A和B的结点组成。 从A、B中挑出最小的元素插入C的尾部，C一定是递增有序的。如果A、B其中一个已经全部插入C中，再将另一个链接到C的尾部即可。 将A和B归并成一个按元素递减的链表C。 改成头插法即可解决。不需要r追踪C的终端结点，而是用s来接收新的结点，插入C的前端。 查找查找链表C中是否存在一个值为x的结点，若存在则删除该结点并返回1，否则返回0。 定义结点指针变量p，沿着链表一直走到表尾，每遇到一个新结点就检测其值是否为x，是则证明找到，不是则继续检测下一个结点。 双链表的操作建立双链表使用尾插法 查找结点在双链表中查找第一个值为x的结点，若找到则返回结点指针，否则返回NULL。 如果找到，则p中内容是结点地址（循环因break结束）；如果没找到，则p中的内容为NULL（循环因p等于NULL而结束）。 插入结点在双链表中p所指的结点之后插入一个结点s。 先将要插入结点的两边链接好，就可以避免断链后找不到结点的情况。 删除结点删除双链表中p结点的后继结点。 循环链表循环链表的各种操作均与非循环链表类似。需要注意的是，如果p指针沿着循环链表行走，则判断p走到表尾结点的条件是p-&gt;next==head。 逆置问题将线性表的元素逆置，可设置两个整形变量i和j，i指向第一个元素，j指向最后一个元素，边交换i和j所指元素，边让i和j相向而行，直到相遇。假设元素存在于数组a[]中，left和right是数组两端元素的下标。 例题 将一个长度为n的数组的前端 k(k&lt;n) 个元素逆序移动到数组后端，要求原数组中数据不丢失，其余元素的位置无关紧要。 将一个长度为n的数组的前端 k(k&lt;n) 个元素保持原序移动到数组后端，要求原数组中数据不丢失，其余元素的位置无关紧要。 将数组中的元素 (X0, X1, …, Xn-1)，经过移动后变为 (Xp, Xp+1, …, Xn-1, X0, X1, …, Xp-1)，即循环左移 p(0&lt;p&lt;n) 个位置。 分析 逆置整个数组，即可满足前端k个元素逆序后放到数组后端。 将前端k个元素逆置，然后将整个数组逆置，即可满足前端k个元素原序放到数组后端。 将0到p-1位置的元素逆置，再将p到n-1位置的元素逆置，然后将整个数组逆置。 栈和队列顺序栈的操作结构体定义 初始化栈只需将栈顶指针置为-1即可。 判断栈空栈st为空时返回1，否则返回0。 进栈 出栈 常用写法栈常常作为一个工具来解决其他问题，因此一般情况下，栈的定义和操作可以写得很简单，不必调用以上函数。 定义一个栈并初始化 元素x进栈 元素x出栈 2与3需注意的是，当前栈是否为满，满时不进；是否为空，空时不出。根据实际需要决定写还是不写，不必像标准操作那样每次都判断。 链栈的操作结点定义 初始化 判断栈空当栈空时返回1，否则返回0。 进栈栈不空时可以执行，返回1，否则返回0。 出栈 和顺序栈一样，不必严格写出操作函数，只需摘取必要的语句结合在代码中即可。 栈的应用顺序栈的应用【例3-1】 C语言算数表达式中的括号只有小括号。编写算法，判断一个表达式中的括号是否正确配对，表达式已经存入字符数组exp[]中，表达式的字符个数为n。 一个问题中如果出现诸如这种情况，即在解决问题的过程中出现了一个子问题，但凭现有条件不能解决它，需要记下，等待以后出现可以解决它的条件后再返回来解决。这种问题需要用栈来解决，这是栈的FILO特性所延申出来的一种特性。 【例3-2】 编写一个函数，求后缀式的数值，其中后缀式存于一个字符数组exp中，其中最后一个字符是\\0作为结束符，并且假设后缀式中的数字都只有一位。本题的除法运算皆为整数运算，如2&#x2F;3结果为0，3&#x2F;2结果为1。 (a+b+c×d)/e是一个中缀式，转化为前缀式为/++ab×cde，转化为后缀式为abcd×++e/。 后缀式的求值可以用栈解决。对于一个后缀式，当从左往右扫描到一个数值时，具体怎么运算还不知道，需要扫描到后面的运算符才知道，因此必须先存起来。 执行过程：当遇到数值时入栈，当遇到运算符时连续两次出栈，将两个出栈元素结合运算符进行运算，将结果作为新遇到的数值入栈。如此往复，直到扫描到终止符\\0。此时栈底元素即为表达式的值。 假设有一个字符&#39;5&#39;，定义一个整形变量a=&#39;5&#39;，此时a里保存了5的ASCII码，而不是数字5。要将5这个整数保存于a中，需执行a=&#39;5&#39;-&#39;0&#39;。同理，把一个整形数字a装华为对应的字符型数字存储在字符变量b中，需执行b=a+&#39;0&#39;。但是这种转化只适用于0~9这10个数字。 链栈的应用【例3-3】 用不带头结点的单链表存储链栈，设计初始化栈、判断栈是否为空、进栈和出栈等算法。 不带头结点的单链表lst为空的条件是lst==NULL，进栈和出栈操作都是在表头进行的。 顺序队结构体定义 以下算法在元素入队时，先移动指针，后存入元素；元素出队时，也是先移动指针，后取出元素。选择题根据实际情况来确定先移动指针还是先存取元素。 初始化队列 判断队空 进队 出队 以上函数在书写程序时并不实用，提出其中有用的操作即可。 链队结构体定义 队节点类型 链队类型 初始化队列 判断队空 入队 出队 不需要记忆，读程序并理解操作意义即可。尽量采用顺序队解决问题，避免采用链队，除非明确规定。 串结构体定义可以用以下语句定义一个名为str的串。 一般不采取这种方式，原因是仅仅以&#39;\\0&#39;作为结束标记，在求串长时需要扫描整个串，时间复杂度为O(n)；不如额外定义一个变量存储长度，求串长变成时间复杂度为O(1)的操作。 定长顺序存储 变长分配存储 使用这种存储方式时，需要用函数malloc()来分配一个长度为length、类型为char的连续存储空间。变长分配存储方法有顺序存储结构的特点，操作中串长可根据需要来设定，更加灵活。 基本操作赋值因为串是一个数组，赋值操作不能用=来实现，必须对数组中的每个元素进行逐一赋值。 函数strassign()使用时格式如下： 将&quot;cur input&quot;赋到str串中。执行后，str.ch的值为”cur input”，str.length的值为9。 取串长度使用变长分配存储的情况下，直接使用str.length语句即可。 在没有给出串长度信息的情况下，可以借鉴函数strassign()中的求输入串的长度部分的代码实现。 串比较设两串A和B中的待比较字符分别为a和b，如果a的ASCII码大于（小于）b的ASCII码，则返回A大于（小于）B的标记；如果a等于b，则继续比较下一对字符。经过上述步骤没有比较出A和B大小的情况下，先结束的串为较小串，两串同时结束则返回相等标记。 串连接将两个串首尾相接，合并成一个字符串。 求子串求str串中从pos位置开始，长度为len的子串，子串由substr返回给用户。 串清空 模式匹配对一个某子串的定位操作称为串的模式匹配，其中待定位的子串称为模式串。 串中字符存储在1~length的位置上，注意区分前面的0~length-1的存储位置。 简单模式匹配算法 KMP算法令简单模式匹配算法中的主串位置i不需要回溯。 定义一个next[j]数组，表示模式串中第j个字符发生不匹配时，应从next[j]处的字符开始重新与主串的不匹配处进行比较。 特殊情况： 模式串中的第一个字符与主串i位置不匹配，从主串的下一字符和模式串的第一个字符继续比较，即从s[i+1]与p[1]开始比较，此时next[1]=0。 前后缀不存在重合部分时，从主串中发生不匹配的字符与模式串的第一个字符继续比较，即从s[i]与p[1]开始比较，此时next[j]=1。 求next数组的算法： 当substr[i-1]==substr[j-1]但substr[i]!=substr[j]时，表示前缀（模式串）中的第j个字符发生不匹配，应从next[j]处的字符开始重新与后缀（主串）比较，即把j的值回溯到next[j]。 得到next数组后，将简单模式匹配算法稍作修改得到KMP算法： KMP算法的改进求nextval的一般步骤： 当j等于1时，next[j]赋值为0。 当p[j]不等于p[k](k = next[j])，nextva[j]赋值为next[j]。 当p[j]等于p[k](k = next[j])，nextva[j]赋值为nextval[next[j]]。 树与二叉树 非空二叉树上叶子结点数等于双分支结点数加1。 总分支数&#x3D;总结点数-1（对任何树都适用） n0&#x3D;1+n2+2n3+…+(m-1)nm 二叉树的存储结构顺序存储 结点 A B C D E 数组下标 0 1 2 3 4 5 用一个数组BTree[]来存储一棵二叉树，最适合完全二叉树。例如，得到A的左孩子结点只需访问BTree[1*2]即可。类似地，如果知道了一个结点i，如果2i不大于n，则i的左孩子结点就存在BTree[2*i]内。 链式存储 二叉树的遍历算法先序遍历递归 非递归 中序遍历递归 非递归 后序遍历递归 非递归 逆后续遍历序列是先序遍历序列过程中交换左右子树遍历顺序得到的结果。需要两个栈，stack1用来辅助做逆后序遍历（交换先序遍历的左右子树遍历顺序），并将遍历结果序列压入stack2，然后将stack2的元素全部出栈，所得即为后续遍历序列。 层次遍历 线索二叉树结构体定义 中序线索二叉树通过中序遍历对二叉树线索化的递归算法： 每当访问一个结点时，如果其左指针为空，就把该指针指向其前驱结点；如果前驱结点的右指针为空，就把该指针指向当前访问结点。 通过中序遍历建立中序线索二叉树的主程序如下： 遍历中序线索二叉树 树和森林与二叉树的转换树与二叉树的相互转换手工转换。 左指针（child）指向孩子，右指针指向兄弟（sibling）。 森林与二叉树的相互转换手工转换。 根结点的右孩子指针指向森林中的下一棵树。 树和森林的遍历只有先序遍历（先根再子树）和后序遍历（先子树再根）。 树或森林转换为二叉树后，先序遍历对应二叉树的先序遍历，后序遍历对应二叉树的中序遍历。 赫夫曼树和赫夫曼编码带权路径长度：从该结点到根之间的路径长度乘以结点的权值。 树的带权路径长度（WPL）是树中所有叶子结点的带权路径长度之和。 赫夫曼树的特点： 权值越大的结点离根结点越近。 没有度为1的结点。又叫做正则（严格）二叉树。 带权路径长度最短。 构造赫夫曼树手工构造。 注意：每次都选出根结点最小的两棵树构造新的二叉树，其中不一定包括上一步构造的二叉树。 赫夫曼编码手工编码，对赫夫曼树的每个结点的左右分支进行编号，左0右1。 赫夫曼编码产生最短前缀码： 前缀码：根通往任一叶子结点的路径都不是通往其余叶子结点路径的子路径，因此任一字符的编码串都不是另一字符编码串的前缀。 最短：每个字符的权值是其出现次数，出现次数越多的字符编码长度越短，因此整个字符串编码后的前缀码长度最短。 图邻接矩阵 如果明确说明采用邻接矩阵表示，并且要求写出邻接矩阵定义，则上述代码全写。 如果没有要求写出邻接矩阵定义，只是说图采用邻接矩阵表示，则不许写出以上代码。但需记住，因为解题中要引用结构体的各成员。 函数f()的参数是一个表示图的结构体变量G。例如，若要取图的顶点数赋值给a，就可以写成a=G.n；若要检测编号为i的顶点和编号为j的顶点是否邻接，则看G.edges[i][j]是否等于1。 邻接表 图的遍历算法深度优先搜索遍历DFS算法执行过程：任取一个顶点，访问之，然后检查这个顶点的所有邻接顶点，递归访问其中未被访问过的顶点。 时间复杂度为O(n+e)。 广度优先搜索遍历算法执行过程： 任取图中一个顶点访问，入队，并将这个顶点标记为已访问。 当队列不空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队。 当队列为空时跳出循环，广度优先搜索完成。 时间复杂度为O(n+e)。 最小（代价）生成树普里姆算法从图中选取一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到一棵有2个顶点的树。然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入当前树中，得到一棵有3个顶点的树。以此类推，直到图中所有顶点都并入树中为止。 普里姆算法的时间复杂度为O(n²)。 克鲁斯卡尔算法每次找出侯选边中权值最小的边，就将该边并入生成树中。重复此过程直到所有边都被检测完为止。检测当前边是否为候选边，即判断该边的并入是否会构成回路，如不构成回路，则将该边并入生成树中。 克鲁斯卡尔算法的时间复杂度主要由选取的排序算法sort()决定。排序算法处理数据的规模由图的边数E决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图。 最短路径迪杰斯特拉算法手工求解 已并入顶点 | 剩余顶点 | dist[] | path[] 时间复杂度为O(n²)。 弗洛伊德算法手工求解 十字交叉法 A-1-A3 | Path-1-Path3 时间复杂度为O(n³)。 拓扑排序手工排序 时间复杂度为O(n+e)，其中n为顶点个数，e为边的条数。 最短路径 根据图求出拓扑有序序列a和逆拓扑有序序列b。 根据a和b分别求出每个事件（顶点）的最早发生时间ve()和最迟发生时间vl()。 根据2中结果求出每个活动（边）的最早发生时间e()和最迟发生时间l()。 根据3中结果找出最早发生时间和最迟发生时间相同的活动，即为关键活动。由关键活动所连成的路径即为关键路径。 活动 | 最早发生时间 | 最迟发生时间 | 关键活动 排序 以下算法基于非递减排序。 插入类排序直接插入排序 时间复杂度：最坏O(n²)，最好O(n)，平均O(n²)。空间复杂度：O(1)。 折半插入排序采用折半查找法来确定插入位置，基本条件是序列已经有序。 时间复杂度：最坏O(n²)，最好O(nlog₂n)，平均O(n²)。空间复杂度：O(1)。 希尔排序手写每一趟排序的执行情况。 时间复杂度与增量选取有关，平均O(nlog₂n)。增量序列的值尽量没有除1以外的公因子，最后一定取1。空间复杂度为O(1)。不稳定。 交换类排序起泡排序 时间复杂度：最坏O(n²)，最好O(n)，平均O(n²)。空间复杂度：O(1)。 快速排序 时间复杂度：最坏O(n²)，最好O(nlog₂n)，平均O(nlog₂n)。空间复杂度：O(log₂n)。不稳定。 选择类排序简单选择排序 时间复杂度：O(n²)，与初始序列无关。空间复杂度：O(1)。 堆排序手工建堆、排序。 从无序序列所确定的完全二叉树的最后一个非叶节点开始，从右往左，从下往上，对每个结点进行调整，得到一个大顶堆。（向下调整） 将当前无序序列中的第一个关键字a（根结点）与最后一个关键字b（最后一个叶子结点）交换。无序序列关键字减少1个，有序序列关键字增加1个。此时只有b可能不满足堆的定义，对其进行调整。 重复第2步，直到无序序列的关键字只剩1个。 插入结点：放在最底层的最右边，然后向上调整。 删除结点：把最底层最右边的叶子的值赋给删除位置，然后向下调整。 时间复杂度：O(nlog₂n)，即使在最坏情况下。这是相对于快速排序最大的优点。 空间复杂度：O(1)，在所有时间复杂度为O(nlog₂n)的排序中是最小的。 二路归并排序 时间复杂度：O(nlog₂n)，与初始序列无关 。空间复杂度：O(n)。 基数排序手工分配收集。 时间复杂度：O(d(n+rd)) 空间复杂度：O(rd) n为序列中的关键字数；d为关键字的位数（如930由3位组成，d&#x3D;3）；rd为关键字基的个数，如关键字为十进制数值时，rd&#x3D;10。 基数排序适合关键字很多，但关键字基较小的序列。如数字0~9是可以接受的，但如果是26个字母而且大多数关键字的最高位不相同，可以考虑“最高位优先”法。 查找顺序查找法 时间复杂度：O(n)。 折半查找法迭代版： 递归版： 时间复杂度：O(log₂n)。 建立折半查找判定树，求平均查找长度。 二叉排序树（二叉查找树）存储结构采用二叉链表进行存储，结点类型定义与一半的二叉树类似。 基本算法查找关键字 与折半查找法相似 插入关键字 首先要找到插入位置。对于一个不存在于二叉排序树中的关键字，查找不成功的位置即为插入位置。 构造二叉排序树 删除关键字 手工操作。 删除p结点： p结点为叶子结点。直接删除即可。 p结点只有左子树，或者只有右子树。将p删掉，并将p的子树直接连接在p与其双亲相连的指针上。 p结点既有左子树又有右子树。沿着p的左子树根结点的右指针一直往右走，直到来到其右子树的最右边一个结点r，然后将p中的关键字用r中的关键字代替。最后判断，如果r是叶子结点，就按照1的方法删除；如果r是非叶子节点，就用2的方法删除。 平衡二叉树（AVL树）平衡二叉树是一种特殊的二叉排序树，其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。 平衡调整 调整失去平衡的最小子树。（任一子树不平衡就需调整） LL调整（右单旋转调整） RR调整（左单旋转调整） LR调整（先左后右双旋转调整） RL调整（先右后左双旋转调整） 删除结点操作与二叉排序树一致。 设Nh表示高度为h的平衡二叉树的最少结点数，则有 N0&#x3D;0, N1&#x3D;1, N2&#x3D;2, …, Nh&#x3D;Nh-1+Nh-2+1 B-树（B树）基本概念。 查找、插入、删除操作。 B+树基本概念。 散列表（Hash表）构造方法 直接定位法 数字分析法 平方取中法 除留余数法：p选择小于等于表长的最大素数 冲突处理方法 开放定址法 以发生冲突的Hash地址为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。 线性探查法：d+1 d+2 ... d+m-1 容易产生堆积问题。 平方探查法：d+1² d-1² d+2² d-2² ... 可以减少堆积问题的出现，不能探查到Hash表上的所有单元，但至少能探测到一半单元。 链地址法 把所有同义词用单链表连接起来。 性能分析查找成功时的平均查找长度是指找到表中已有表项的平均比较次数（分母是关键字个数）； 查找不成功时的平均查找长度是指在表中找不到待查的表项，但找到插入位置的平均比较次数（分母是表长度）。 装填因子是关键字个数与表长度的比值。"},{"title":"Hello World","date":"2023-01-07T01:52:00.000Z","url":"/2023/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]